<script>
  // ÂÖ®ÂüüËÆäÊï∏Ôºà‰æõ Analytics ÂäüËÉΩ‰ΩøÁî®Ôºâ
  let tableData = [];
  let newRowTravelEnabled = true;
  let selectedMonth = null;
  let charts = {};
  let chartsInitialized = false;
  let availableMonths = [];

  ; (function (global) {
    // Âú® Apps ScriptÔºàÂæåÁ´ØÔºâ‰πüÊúÉËºâÂÖ•ÈÄôÂÄãÊ™îÊ°àÔºå‰ΩÜÊ≤íÊúâ window / documentÔºåÊâÄ‰ª•ÈÄôË£°Áî® globalThis/this ÂÅöÈò≤ÂëÜ
    if (!global || !global.document) {
      return;
    }
    global.__BUILD_TAG__ = '2025-12-28-v2';
    console.log('[OT] BUILD', global.__BUILD_TAG__);

    // ËÆäÊï∏Â∑≤ÁßªËá≥ÂÖ®Âüü
    // --- Helper Functions ---
    function safeParseFloat(val) {
      if (val === undefined || val === null || val === '') return 0;
      if (typeof val === 'number') return val;
      // ÁßªÈô§ÈÄóËôüÂæåÂÜçËΩâÊèõ
      const clean = val.toString().replace(/,/g, '');
      return parseFloat(clean) || 0;
    }

    // iOS Safari ÂÖºÂÆπÁöÑÊó•ÊúüËß£Êûê (YYYY/MM/DD Êàñ YYYY-MM-DD)
    function parseDateSafe(dateStr) {
      if (!dateStr) return new Date();
      if (dateStr instanceof Date) return dateStr;
      let s = String(dateStr).trim();
      if (s.indexOf('T') !== -1) return new Date(s);
      // Â∞á - ÊõøÊèõÁÇ∫ / ÊòØ iOS Safari ÊúÄ‰øùÈö™ÁöÑÂÅöÊ≥ï
      return new Date(s.replace(/-/g, '/'));
    }

    // Â∞áÂêÑÁ®ÆÊ†ºÂºè (ISO, Date Â≠ó‰∏≤, Êï∏ÂÄº) ËΩâÁÇ∫ HH:mm Ê†ºÂºè
    function normalizeTime(val) {
      if (!val) return '';
      const s = val.toString().trim();
      if (!s) return '';

      // ÊÉÖÊ≥Å A: ISO Ê†ºÂºèÊàñÂåÖÂê´ T ÁöÑÂ≠ó‰∏≤ (Google Sheets Â∏∏Ë¶ã)
      // ‰æãÂ¶Ç 1899-12-30T17:30:00.000Z Êàñ 2024-01-01T21:00:00
      if (s.includes('T') || (s.includes(' ') && s.includes('-'))) {
        const d = new Date(s);
        if (!isNaN(d.getTime())) {
          return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
        }
      }

      // ÊÉÖÊ≥Å B: Âè™ÊúâÊôÇÈñìÈÉ®ÂàÜ ÊàñÂåÖÂê´ 1899 ÁöÑÁ©∫Ê†ºÂ≠ó‰∏≤
      // ‰æãÂ¶Ç "23:23" Êàñ "1899/12/30 23:23:00"
      const timeMatch = s.match(/(\d{1,2}):(\d{1,2})/);
      if (timeMatch) {
        // Âç≥‰ΩøÂåπÈÖçÂà∞‰∫ÜÔºåÂ¶ÇÊûúÊòØ 1899/12/30 ÈÄôÁ®ÆÔºåÁõ¥Êé•Áî® Regex ÊäìÊúÄÂæåÁöÑÊôÇÈñìÊÆµÊúÄ‰øùÈö™
        const parts = s.split(' ');
        const lastPart = parts[parts.length - 1];
        if (lastPart.includes(':')) {
          const [h, m] = lastPart.split(':');
          return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        }
      }

      return s;
    }

    // Âº∑ÂåñÁâàÊú¨ localStorage Â≠òÂèñ (ÈÅøÂÖç GAS iframe ÊàñÁÑ°ÁóïÊ®°ÂºèÂ§±Êïà)
    const storage = {
      get: (key) => {
        try {
          return localStorage.getItem(key);
        } catch (e) {
          console.warn(`[OT] localStorage.get(${key}) failed:`, e);
          return null;
        }
      },
      set: (key, val) => {
        try {
          localStorage.setItem(key, val);
          return true;
        } catch (e) {
          console.warn(`[OT] localStorage.set(${key}) failed:`, e);
          return false;
        }
      }
    };

    function getWeekdayChar(dateStr) {
      const date = parseDateSafe(dateStr);
      const weekdays = ['Êó•', '‰∏Ä', '‰∫å', '‰∏â', 'Âõõ', '‰∫î', 'ÂÖ≠'];
      return weekdays[date.getDay()];
    }

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    const debouncedUpdateAnalytics = debounce(() => {
      updateCharts();
      updateAnalyticsStats();
    }, 300);

    function formatDateYYYYMMDD(d) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }

    // Ê†πÊìöÂúãÂÆ∂‰ª£Á¢ºÂèñÂæóÊØèÊó• Travel USD (Dynamic from localStorage)
    function getTravelUsdByCountry(country) {
      if (!country || country === 'None') return 0;
      const rates = getTravelRates();
      return safeParseFloat(rates[country]) || 40; // Default to 40 if not found
    }

    function getCountryAbbr(country) {
      if (!country || country === 'None') return '';
      const mapping = {
        'Vietnam': 'VN',
        'India': 'IN',
        'China': 'CN',
        'Taiwan': 'TW',
        'Japan': 'JP',
        'Thailand': 'TH',
        'Korea': 'KR'
      };
      return mapping[country] || country.slice(0, 2).toUpperCase();
    }

    // Centralized settings state
    let globalSettings = {
      salaryHistory: [{ date: '2000-01', amount: 68000 }],
      travelRates: { 'Vietnam': 40, 'China': 32.05, 'India': 75 },
      usdRate: 32.5,
      rules: {} // Placeholder for OT calculation rules
    };

    function loadLocalSettings() {
      try {
        const stored = storage.get('globalSettings');
        if (stored) {
          globalSettings = JSON.parse(stored);
        } else {
          // Fallback to old keys for backward compatibility
          const sh = storage.get('salaryHistory');
          const tr = storage.get('travelRates');
          if (sh) globalSettings.salaryHistory = JSON.parse(sh);
          if (tr) globalSettings.travelRates = JSON.parse(tr);
        }
      } catch (e) { console.warn('[OT] Failed to load local settings:', e); }

      // Ensure sorting
      if (globalSettings.salaryHistory) {
        globalSettings.salaryHistory.sort((a, b) => b.date.localeCompare(a.date));
      }
    }
    loadLocalSettings();

    function getTravelRates() {
      return globalSettings.travelRates;
    }

    // Êõ¥Êñ∞: ÈáçÊñ∞Ë®àÁÆóÊâÄÊúâË≥áÊñôÔºå‰∏¶ÈáçÊñ∞Ê∏≤Êüì
    function updateAll(openIndex = null, skipRender = false) {
      try {
        const salaryHistory = globalSettings.salaryHistory;
        const rateInput = document.getElementById('usdRate');
        let rate = globalSettings.usdRate || 32.5;
        if (rateInput && rateInput.value !== '') {
          rate = safeParseFloat(rateInput.value);
        }
        globalSettings.usdRate = rate;
        if (rateInput && document.activeElement !== rateInput) {
          rateInput.value = rate;
        }
        // const travelUsdPerDay = getTravelUsdByCountry(); // ‰∏çÂÜç‰ΩøÁî®ÂÖ®ÂüüË®≠ÂÆö

        // 1. ÂÖàÊåâÊó•Êúü„ÄåÁî±ËàäÂà∞Êñ∞„ÄçÊéíÂ∫èÔºåÁ¢∫‰øùÁ¥ØÂä†Ë®àÁÆó (accum) Ê≠£Á¢∫
        tableData.sort((a, b) => parseDateSafe(a.date) - parseDateSafe(b.date));

        let accum = 0;
        const monthTravelSums = {}; // key: 'YYYY-MM' -> Ë©≤Êúà Travel Âä†Á∏Ω
        const monthOtSalarySums = {}; // key: 'YYYY-MM' -> Ë©≤Êúà OT Salary Âä†Á∏Ω

        // Áî±ÂâçÁ´Ø‰æù salary / rate / travel Ë®≠ÂÆöÈáçÊñ∞Ë®àÁÆó
        tableData.forEach((entry) => {
          const date = parseDateSafe(entry.date);
          const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
          const isHoliday = !!entry.isHoliday;

          const mults = getOTMultipliers();
          let m134 = mults.weekday_134;
          let m167 = mults.weekday_167;
          let m166 = mults.holiday_200; // Holiday base bucket
          let m267 = mults.weekend_267; // Default for 9h+ if weekend? (logic below overrides)

          if (isWeekend && !isHoliday) {
            // Saturday/Sunday: Base (1.0) is already in monthly salary. 
            // We use the configured weekend multipliers
            m134 = mults.weekend_134 - 1.0; // i.e. 1.34 - 1.0 = 0.34
            m167 = mults.weekend_167 - 1.0; // i.e. 1.67 - 1.0 = 0.67
            m267 = mults.weekend_267; // 9h+ (no base usually)
          } else if (isHoliday) {
            // Holiday rules
            m166 = mults.holiday_200 - 1.0; // i.e. 2.0 - 1.0 = 1.0
            m134 = mults.weekday_134;
            m167 = mults.weekday_167;
          }

          const otSum =
            (safeParseFloat(entry.v167) || 0) * m167 +
            (safeParseFloat(entry.v134) || 0) * m134 +
            (safeParseFloat(entry.v166) || 0) * m166 +
            (safeParseFloat(entry.v267) || 0) * m267;

          // Ë≥áÊñôÈÅ∑ÁßªÔºöËàäË≥áÊñô travelEnabled=true ËΩâÁÇ∫ VietnamÔºåfalse ËΩâÁÇ∫ None
          if (!entry.travelCountry) {
            if (entry.travelEnabled === false) entry.travelCountry = 'None';
            else entry.travelCountry = 'Vietnam';
          }

          const isLeave = !!entry.isLeave;
          if (isLeave && !entry.leaveType) {
            entry.leaveType = 'Áâπ‰ºë';
            entry.leaveAmount = 1;
          }
          const otHours = (safeParseFloat(entry.v167) || 0) + (safeParseFloat(entry.v134) || 0) + (safeParseFloat(entry.v166) || 0) + (safeParseFloat(entry.v267) || 0);

          // Find applicable salary from history
          const entryMonth = entry.date ? entry.date.slice(0, 7) : '0000-00';
          const applicable = salaryHistory.find(h => h.date <= entryMonth) || salaryHistory[salaryHistory.length - 1];
          const salary = applicable ? safeParseFloat(applicable.amount) : 68000;

          const base = (isLeave && entry.leaveType !== 'Áâπ‰ºë') ? 0 : (salary / 30);
          const travelUsd = isLeave ? 0 : getTravelUsdByCountry(entry.travelCountry);
          const travel = travelUsd * rate;
          const otSalary = isLeave ? 0 : ((salary / 30 / 8) * otSum);
          const total = base + travel + otSalary;

          accum += total;

          entry.isLeave = isLeave; // Ensure boolean
          entry.otSum = (otSum || 0).toFixed(2);
          entry.otHours = (otHours || 0).toFixed(1);
          entry.totalOtHoursNumeric = otHours; // Real number for display logic
          entry.base = (base || 0).toFixed(2);
          entry.travel = (travel || 0).toFixed(2);
          entry.otSalary = (otSalary || 0).toFixed(2);
          entry.total = (total || 0).toFixed(2);
          entry.accum = (accum || 0).toFixed(2);
          entry.weekday = getWeekdayChar(entry.date);

          // ‰æùÊúà‰ªΩÁ¥ØÁ©çÔºöÁï∂Êúà Travel Ëàá OT SalaryÔºà‰∏çÂê´ BaseÔºâ
          const monthKey = entry.date ? entry.date.slice(0, 7) : '';
          if (monthKey) {
            monthTravelSums[monthKey] = (monthTravelSums[monthKey] || 0) + travel;
            monthOtSalarySums[monthKey] = (monthOtSalarySums[monthKey] || 0) + otSalary;
          }
        });

        // ‰æùÊúà‰ªΩÂõûÂØ´„ÄåÊúàËñ™„ÄçÊ¨Ñ‰Ωç
        tableData.forEach((entry) => {
          const monthKey = entry.date ? entry.date.slice(0, 7) : '';
          if (monthKey) {
            const travelSum = monthTravelSums[monthKey] || 0;
            const otSalarySum = monthOtSalarySums[monthKey] || 0;

            const applicable = salaryHistory.find(h => h.date <= monthKey) || salaryHistory[salaryHistory.length - 1];
            const salary = applicable ? safeParseFloat(applicable.amount) : 68000;

            entry.monthSLR = (salary + travelSum + otSalarySum).toFixed(0);
          }
        });

        // 2. Ë®àÁÆóÂÆåÁï¢ÂæåÔºåÈÇÑÂéüÁÇ∫„ÄåÈ°ØÁ§∫Áî®ÊéíÂ∫è„ÄçÔºöÊúà‰ªΩÁî±Êñ∞Âà∞ËàäÔºåÊó•ÊúüÁî±ËàäÂà∞Êñ∞ (Calendar Style)
        tableData.sort((a, b) => {
          const dA = parseDateSafe(a.date);
          const dB = parseDateSafe(b.date);
          const mA = dA.getFullYear() * 12 + dA.getMonth();
          const mB = dB.getFullYear() * 12 + dB.getMonth();
          if (mA !== mB) return mB - mA;
          return dA - dB;
        });

        if (!skipRender) {
          renderDataList(openIndex);
          updateTableValues();
          // Ensure charts and stats stay in sync
          updateCharts();
          updateAnalyticsStats();
        }
        // Êõ¥Êñ∞ÂÖ®Âüü Month Header Chiplist
        if (global.updateMonthStatsDOM) {
          global.updateMonthStatsDOM();
        }

        updateDashboard();
        updateLeaveSummaryDOM();
        debouncedUpdateAnalytics();

        // [Audit Fix] Add local persistence fallback
        storage.set('overtimeData', JSON.stringify(tableData));
      } catch (err) {
        console.error('[OT] updateAll ÁôºÁîüÈ†êÊúüÂ§ñÈåØË™§:', err);
        showNotification('‚ùå Ë®àÁÆóÊõ¥Êñ∞Â§±ÊïóÔºåË´ãÊ™¢Êü•Ë≥áÊñôÊ†ºÂºè', true);
      }
    }

    // Êõ¥Êñ∞Ë°®Ê†º‰∏≠Â∑≤Ê∏≤ÊüìÁöÑÊï∏ÂÄºÔºà‰∏çÈáçÊñ∞Âª∫Á´ã DOMÔºâ
    function updateTableValues() {
      const rows = document.querySelectorAll('.data-row');
      rows.forEach((row, index) => {
        const entry = tableData[index];
        if (!entry) return;

        // Êõ¥Êñ∞ OT Êï∏ÂÄºÈ°ØÁ§∫
        const steppers = row.querySelectorAll('.stepper-value');
        steppers.forEach((valueSpan, i) => {
          const keys = ['v167', 'v134', 'v166', 'v267'];
          if (entry[keys[i]] !== undefined) {
            valueSpan.textContent = entry[keys[i]];
            // Êõ¥Êñ∞ class
            if (entry[keys[i]] > 0) {
              valueSpan.classList.add('has-value');
            } else {
              valueSpan.classList.remove('has-value');
            }
          }
        });

        // Êõ¥Êñ∞Á∏ΩË®à
        const totalSpan = row.querySelector('.total-value');
        if (totalSpan) {
          totalSpan.textContent = Math.round(entry.total);
          totalSpan.classList.add('privacy-hidden');
        }
      });
    }
    function fillMissingDatesToToday() {
      if (!tableData.length) {
        showNotification('‚ùå ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïË≥áÊñôÔºåÁÑ°Ê≥ïËá™ÂãïË£úÊªøÊó•Êúü', true);
        return;
      }

      // ÊâæÂá∫ÁõÆÂâçË≥áÊñô‰∏≠„ÄåÊúÄÊñ∞„ÄçÊó•Êúü
      let latest = null;
      tableData.forEach((entry) => {
        if (!entry.date) return;
        const d = parseDateSafe(entry.date);
        if (!latest || d > latest) {
          latest = d;
        }
      });

      if (!latest) {
        showNotification('‚ùå ÁõÆÂâçË≥áÊñôÊó•ÊúüÊ†ºÂºèÁï∞Â∏∏ÔºåÁÑ°Ê≥ïËá™ÂãïË£úÊªøÊó•Êúü', true);
        return;
      }

      const latestDateStr = formatDateYYYYMMDD(latest); // Corrected this line
      const latestDateObj = parseDateSafe(latestDateStr);
      const startDate = new Date(latestDateObj.getFullYear(), latestDateObj.getMonth(), latestDateObj.getDate() + 1);
      const today = new Date();
      const todayDateOnly = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      let added = 0; // Initialize added counter
      const addedDates = []; // Initialize addedDates array

      if (startDate > todayDateOnly) {
        showNotification('‚úÖ ÁõÆÂâçÂ∑≤Ë£úÊªøËá≥‰ªäÊó•ÔºåÊ≤íÊúâÊñ∞Â¢ûË≥áÊñô');
        return;
      }

      for (let d = new Date(startDate); d <= todayDateOnly; d.setDate(d.getDate() + 1)) {
        const dateStr = formatDateYYYYMMDD(d);
        const newEntry = {
          date: dateStr,
          v167: 0,
          v134: 0,
          v166: 0,
          v267: 0,
          remark: '',
          travelEnabled: newRowTravelEnabled,
        };
        tableData.push(newEntry);
        added++;
        addedDates.push(dateStr);
      }

      if (!added) {
        showNotification('‚úÖ ÁõÆÂâçÂ∑≤Ë£úÊªøËá≥‰ªäÊó•ÔºåÊ≤íÊúâÊñ∞Â¢ûË≥áÊñô');
        return;
      }

      // ÈáçÊñ∞ÊéíÂ∫è‰∏¶ÈáçÁÆó (Êúà‰ªΩÁî±Êñ∞Âà∞ËàäÔºåÊó•ÊúüÁî±ËàäÂà∞Êñ∞)
      tableData.sort((a, b) => {
        const dA = new Date(a.date);
        const dB = new Date(b.date);
        const mA = dA.getFullYear() * 12 + dA.getMonth();
        const mB = dB.getFullYear() * 12 + dB.getMonth();
        if (mA !== mB) return mB - mA;
        return dA - dB;
      });
      updateAll();

      const first = addedDates[0];
      const last = addedDates[addedDates.length - 1];

      const formatMMDD = (iso) => {
        const mm = iso.slice(5, 7);
        const dd = iso.slice(8, 10);
        return `${mm}${dd}`;
      };

      const msg = `‚úÖ Êñ∞Â¢û ${added} Á≠ÜÔºåÂæû ${formatMMDD(first)} Âà∞ ${formatMMDD(last)}`;
      showNotification(msg);
    }

    // Êñ∞Â¢ûË≥áÊñô
    function addNewEntry(entry) {
      tableData.push(entry);
      tableData.sort((a, b) => {
        const dA = new Date(a.date);
        const dB = new Date(b.date);
        const mA = dA.getFullYear() * 12 + dA.getMonth();
        const mB = dB.getFullYear() * 12 + dB.getMonth();
        if (mA !== mB) return mB - mA;
        return dA - dB;
      });
      updateAll();
    }

    // Âà™Èô§Ë≥áÊñô
    function deleteEntry(index) {
      if (index >= 0 && index < tableData.length) {
        tableData.splice(index, 1);
        updateAll();
        showNotification('üóëÔ∏è Ë≥áÊñôÂ∑≤Âà™Èô§');
      }
    }

    // Ë™øÊï¥ OT Êï∏ÂÄºÔºà‰∏çÈáçÊñ∞Ê∏≤ÊüìË°®Ê†ºÔºåÂè™Êõ¥Êñ∞Êï∏ÂÄºÔºâ
    function adjustOTValue(entry, key, delta) {
      if (key === 'vH' || key === 'vM') {
        const timeStr = normalizeTime(entry.endTime) || '17:30';
        let [hStr, mStr] = timeStr.split(':');
        let h = parseInt(hStr, 10);
        let m = parseInt(mStr, 10);

        // Fallback for NaN (should not happen with normalizeTime but stay safe)
        if (isNaN(h)) h = 17;
        if (isNaN(m)) m = 30;

        if (key === 'vH') {
          h = (h + delta + 24) % 24;
        } else {
          m = (m + delta * 10 + 60) % 60; // 10 min steps
        }
        entry.endTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

        // Recalculate buckets
        const res = calculateOvertime(h, m, entry.date, entry.isHoliday);
        entry.v134 = res.v134;
        entry.v167 = res.v167;
        entry.v267 = res.v267;
        entry.v166 = res.v166;
        entry.totalOtHoursNumeric = res.total;

        updateAll(null, true);
        return;
      }
      const newVal = Math.max(0, (entry[key] || 0) + delta);
      entry[key] = newVal;

      // Âè™Êõ¥Êñ∞Ë©≤ÂàóÁöÑÊï∏ÂÄºÂíåË®àÁÆóÁµêÊûúÔºå‰∏çÈáçÊñ∞Ê∏≤ÊüìÊï¥ÂÄãË°®Ê†º
      updateAll(null, true); // ÂÇ≥ÂÖ• skipRender=true
    }

    // --- Rules Modal Logic ---
    function getOTMultipliers() {
      const stored = storage.get('otMultipliers');
      const defaults = {
        weekday_134: 1.34,
        weekday_167: 1.67,
        weekend_134: 1.34,
        weekend_167: 1.67,
        weekend_267: 2.67,
        holiday_200: 2.00
      };
      if (!stored) return defaults;
      try {
        return { ...defaults, ...JSON.parse(stored) };
      } catch (e) {
        return defaults;
      }
    }

    function editMultiplier(key) {
      const mults = getOTMultipliers();
      const current = mults[key];
      const newVal = prompt(`Ë´ãËº∏ÂÖ•Êñ∞ÁöÑÂÄçÁéá (ÁõÆÂâç: ${current}x):`, current);

      if (newVal !== null) {
        const floatVal = parseFloat(newVal);
        if (isNaN(floatVal)) {
          showNotification('‚ùå Ë´ãËº∏ÂÖ•ÊúâÊïàÁöÑÊï∏Â≠ó', true);
          return;
        }
        mults[key] = floatVal;
        storage.set('otMultipliers', JSON.stringify(mults));
        renderMultiplierRules();
        updateAll();
        showNotification('‚úÖ ÂÄçÁéáÂ∑≤Êõ¥Êñ∞‰∏¶ÂÑ≤Â≠ò');
      }
    }

    function renderMultiplierRules() {
      const mults = getOTMultipliers();
      const mapping = {
        'weekday_134': 'm_weekday_134',
        'weekday_167': 'm_weekday_167',
        'weekend_134': 'm_weekend_134',
        'weekend_167': 'm_weekend_167',
        'weekend_267': 'm_weekend_267',
        'holiday_200': 'm_holiday_200'
      };

      for (const [key, id] of Object.entries(mapping)) {
        const el = document.getElementById(id);
        if (el) {
          el.textContent = `${mults[key].toFixed(2)}x`;
        }
      }
    }

    function openRulesModal() {
      const modal = document.getElementById('rulesModal');
      if (modal) {
        renderMultiplierRules();
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }
    }

    function closeRulesModal() {
      const modal = document.getElementById('rulesModal');
      if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    }

    global.openRulesModal = openRulesModal;
    global.closeRulesModal = closeRulesModal;
    global.editMultiplier = editMultiplier;

    // Êï∏Â≠óÁøªÁâåÂãïÁï´ÈÄöÁî® helperÔºàÈÄê‰ΩçÊï∏Ôºâ
    function setAnimatedNumber(element, newValue) {
      if (!element) return;
      const newText = String(newValue);
      const oldText = element.dataset.value ?? element.textContent;

      if (oldText === newText) {
        element.dataset.value = newText;
        return;
      }

      element.dataset.value = newText;
      element.innerHTML = '';

      for (let i = 0; i < newText.length; i++) {
        const ch = newText[i];
        const span = document.createElement('span');
        span.textContent = ch;
        span.classList.add('digit');
        if (oldText[i] !== ch) {
          span.classList.add('flip');
        }
        element.appendChild(span);
      }
    }

    // Á∞°ÂñÆÁöÑÈÄöÁü•Ê∞£Ê≥°ÔºàÊàêÂäü / Â§±ÊïóÊèêÁ§∫Ôºâ
    function showNotification(message, isError = false) {
      let bubble = document.getElementById('otNotifyBubble');
      if (!bubble) {
        bubble = document.createElement('div');
        bubble.id = 'otNotifyBubble';
        bubble.classList.add('ot-notify-bubble');

        const old = document.querySelector('.ot-notify-bubble:not(#otNotifyBubble)');
        if (old) old.remove();

        // Ê®£ÂºèË®≠ÂÆö
        bubble.style.position = 'fixed';
        bubble.style.padding = '12px 24px';
        bubble.style.borderRadius = '12px';
        bubble.style.color = '#fff';
        bubble.style.fontWeight = '500';
        bubble.style.boxShadow = '0 8px 24px rgba(0,0,0,0.25)';
        bubble.style.zIndex = '9999';
        bubble.style.backdropFilter = 'blur(10px)';
        bubble.style.webkitBackdropFilter = 'blur(10px)';
        bubble.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        bubble.style.opacity = '0';
        bubble.style.pointerEvents = 'none';
        bubble.style.whiteSpace = 'pre-wrap'; /* Support multiline text */
        bubble.style.textAlign = 'left';      /* Align text to left for list */
        bubble.style.lineHeight = '1.5';
        bubble.style.left = '50%';
        bubble.style.top = '50%';
        bubble.style.transform = 'translate(-50%, -50%)';
        bubble.style.maxWidth = '320px';

        document.body.appendChild(bubble);
      }

      if (isError) {
        bubble.style.background = 'rgba(255, 59, 48, 0.9)';
      } else {
        bubble.style.background = 'rgba(0, 0, 0, 0.8)';
      }

      bubble.textContent = message;
      document.body.appendChild(bubble);

      // ÂÆö‰ΩçË®àÁÆó
      const logoCard = document.querySelector('.logo-card');
      if (logoCard) {
        const rect = logoCard.getBoundingClientRect();
        bubble.style.left = rect.left + 'px';
        bubble.style.width = rect.width + 'px'; // Ëàá Logo ÂêåÂØ¨
        bubble.style.boxSizing = 'border-box'; // Á¢∫‰øù padding ‰∏çÊíêÂ§ß
        bubble.style.textAlign = 'center';

        // ÂàùÂßã‰ΩçÁΩÆÔºöÂú® Logo Â∫ïÈÉ®‰∏äÊñπ‰∏ÄÈªûÔºàÈö±ËóèÁãÄÊÖãÔºâ
        const startTop = rect.bottom - 20;
        const endTop = rect.bottom + 10;

        bubble.style.top = endTop + 'px';
        bubble.style.transform = `translateY(-${endTop - startTop}px) scale(0.9)`;

        // Ëß∏ÁôºÈáçÁπ™
        requestAnimationFrame(() => {
          bubble.style.opacity = '1';
          bubble.style.transform = 'translateY(0) scale(1)';
        });
      } else {
        // Fallback: ÁΩÆ‰∏≠È°ØÁ§∫
        bubble.style.top = '20px';
        bubble.style.left = '50%';
        bubble.style.transform = 'translateX(-50%) translateY(-20px)';
        requestAnimationFrame(() => {
          bubble.style.opacity = '1';
          bubble.style.transform = 'translateX(-50%) translateY(0)';
        });
      }

      // Ëá™ÂãïÊ∂àÂ§±
      setTimeout(() => {
        bubble.style.opacity = '0';
        bubble.style.transform = 'translateY(-20px) scale(0.9)'; // Âêë‰∏äÊî∂Âõû
        setTimeout(() => bubble.remove(), 400);
      }, 3000);
    }

    // ÂêåÊ≠• Travel Toggle UIÔºàÊñ∞Â¢ûÂàó‰∏äÁöÑ Travel ÊåâÈàïÔºâ
    function syncTravelToggleUI() {
      const travelToggleBtn = document.getElementById('travelToggle');
      if (travelToggleBtn) {
        if (newRowTravelEnabled) {
          travelToggleBtn.classList.add('on');
        } else {
          travelToggleBtn.classList.remove('on');
        }
      }
    }

    // --- OT Calculation Logic (Time-Based) ---
    const OT_RULES = {
      weekday: { offTime: 17.5, break: 0 }, // 17:30
      weekend: { startTime: 8.0, breakStart: 12.0, breakEnd: 13.5 }
    };

    /**
  * Calculate OT hours based on End Time and Date
  * @param {number} h - Hour (0-23)
  * @param {number} m - Minute (0-59)
  * @param {string} dateStr - YYYY-MM-DD
  * @param {boolean} isHoliday - Manually toggled National Holiday
  */
    function calculateOvertime(h, m, dateStr, isHoliday = false) {
      // Defensive checks for NaN
      if (isNaN(h) || isNaN(m)) {
        console.warn('[OT] calculateOvertime called with NaN values:', h, m);
        return { v134: 0, v167: 0, v166: 0, v267: 0, total: 0 };
      }
      const date = parseDateSafe(dateStr);
      const isWeekend = (date.getDay() === 0 || date.getDay() === 6); // Sat or Sun
      const timeVal = h + (m / 60);

      let v134 = 0, v167 = 0, v267 = 0; // v267 is effectively 2.67 rate OR holiday 2.0 bucket if we misuse it?
      // User requested: "Database columns c/d/e/f originally 1.67/1.34/1.66/2.67. 
      // I have merged 1.66 into 1.67, and changed 1.66 to 2 (Holiday 1x + 1x = 2x total for first 8h)."
      // So: 
      // v167 field -> 1.67x
      // v134 field -> 1.34x
      // v166 field -> 2.0x (National Holiday First 8h)
      // v267 field -> 2.67x (Weekend >8h)

      // Wait, let's map strictly to what user asked: 
      // "Ââç8Â∞èÊôÇÁµ¶‰ªò1ÂÄçËñ™Ë≥á(ÂÖ±2ÂÄç)ÔºåË∂ÖÈÅéÈÉ®ÂàÜÊåâÂπ≥Êó•Âä†Áè≠Ë≤ªÁéáÔºà9-10Â∞èÊôÇ 1.34ÂÄçÔºå11-12Â∞èÊôÇ 1.67ÂÄçÔºâÂä†Áµ¶"
      // So Holiday:
      // 0-8h: 1x (Total 2x) -> Map to v166 (renamed concept to v200 internally or just use v166 slot)
      // 8-10h: 1.34x -> Map to v134
      // 10h+: 1.67x -> Map to v167

      const mults = getOTMultipliers();

      if (isHoliday) {
        // ...Ë¶èÂâáËàáÂπ≥Êó•Áõ∏ÂêåÈÉ®ÂàÜ‰øùÊåÅ‰∏çËÆäÔºå‰ΩÜ‰ΩøÁî®ËÆäÈáè...
        let workDuration = 0;
        const start = OT_RULES.weekend.startTime;
        const bStart = OT_RULES.weekend.breakStart;
        const bEnd = OT_RULES.weekend.breakEnd;

        if (timeVal <= start) workDuration = 0;
        else if (timeVal <= bStart) workDuration = timeVal - start;
        else if (timeVal <= bEnd) workDuration = bStart - start;
        else workDuration = (bStart - start) + (timeVal - bEnd);

        if (workDuration > 0) {
          const v200Hours = Math.min(8, workDuration);
          const rem = Math.max(0, workDuration - 8);
          const v134Hours = Math.min(2, rem);
          const v167Hours = Math.max(0, rem - 2);
          return { v134: v134Hours, v167: v167Hours, v166: v200Hours, v267: 0, total: (v134Hours + v167Hours + v200Hours) };
        }
        return { v134: 0, v167: 0, v166: 0, v267: 0, total: 0 };

      } else if (isWeekend) {
        let workDuration = 0;
        const start = OT_RULES.weekend.startTime;
        const bStart = OT_RULES.weekend.breakStart;
        const bEnd = OT_RULES.weekend.breakEnd;

        if (timeVal <= start) workDuration = 0;
        else if (timeVal <= bStart) workDuration = timeVal - start;
        else if (timeVal <= bEnd) workDuration = bStart - start;
        else workDuration = (bStart - start) + (timeVal - bEnd);

        if (workDuration > 0) {
          v134 = Math.min(2, workDuration);
          const rem1 = Math.max(0, workDuration - 2);
          v167 = Math.min(6, rem1);
          v267 = Math.max(0, rem1 - 6);
        }
        return { v134, v167, v267, v166: 0, total: workDuration };
      } else {
        let effectiveTime = timeVal;
        if (effectiveTime < 6) effectiveTime += 24;
        const otDuration = effectiveTime - OT_RULES.weekday.offTime;
        if (otDuration > 0) {
          v134 = Math.min(2, otDuration);
          v167 = Math.max(0, otDuration - 2);
        }
        return { v134, v167, v267: 0, v166: 0, total: (v134 + v167) };
      }
    }

    /**
     * Reverse calculate End Time from existing OT data
     * Used for recreating HH:MM state from loaded data
     */
    function getReverseTime(entry) {
      // Check if we have explicit endTime stored
      const explicitTime = normalizeTime(entry.endTime);
      if (explicitTime) {
        const [h, m] = explicitTime.split(':').map(Number);
        if (!isNaN(h) && !isNaN(m)) {
          return { h, m };
        }
      }

      // Otherwise derive from OT hours
      const date = parseDateSafe(entry.date);
      const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
      const isHoliday = !!entry.isHoliday;
      const v134 = safeParseFloat(entry.v134);
      const v167 = safeParseFloat(entry.v167);
      const v267 = safeParseFloat(entry.v267);
      const v166 = safeParseFloat(entry.v166);
      const otSum = v134 + v167 + v267 + v166;

      let timeVal = 0;

      if (isHoliday || isWeekend) {
        // Holiday or Weekend: Reverse work duration
        // For Holidays, otSum includes the first 8h. For Weekends, it depends on start time.
        // Actually, let's treat BOTH as 8:00 start + sum of hours (including break if > 4h)
        if (otSum <= 4) {
          timeVal = OT_RULES.weekend.startTime + otSum;
        } else {
          timeVal = OT_RULES.weekend.breakEnd + (otSum - 4);
        }
      } else {
        // Normal Weekday: 17.5 + OT
        timeVal = OT_RULES.weekday.offTime + otSum;
      }

      // If timeVal is NaN for some reason, fallback to default
      if (isNaN(timeVal)) {
        timeVal = OT_RULES.weekday.offTime;
      }

      // Convert decimal to H:M (Round to nearest 10m)
      let h = Math.floor(timeVal);
      let m = Math.round((timeVal - h) * 60);

      // Snap to 10m
      m = Math.round(m / 10) * 10;
      if (m === 60) { h++; m = 0; }

      // Fix edges: Allow up to 30.0 (6 AM) for internal tracking, but usually h % 24 for display
      h = h % 24;
      return { h, m };
    }

    function renderCapsuleSelector(options, currentValue, onSelect) {
      const container = document.createElement('div');
      container.className = 'capsule-container';

      const toggle = document.createElement('button');
      toggle.className = 'capsule-toggle';
      toggle.textContent = currentValue || 'Ë´ãÈÅ∏Êìá';
      container.appendChild(toggle);

      const popup = document.createElement('div');
      popup.className = 'capsule-popup';

      options.forEach(opt => {
        const optionEl = document.createElement('div');
        optionEl.className = 'capsule-option';
        const isSelected = (opt.value === currentValue || opt === currentValue);
        if (isSelected) optionEl.classList.add('selected');
        optionEl.textContent = opt.label || opt;
        optionEl.onclick = (e) => {
          e.stopPropagation();
          onSelect(opt.value || opt);
          toggle.textContent = opt.label || opt;
          popup.classList.remove('open');
          toggle.classList.remove('active');
        };
        popup.appendChild(optionEl);
      });
      container.appendChild(popup);

      toggle.onclick = (e) => {
        e.stopPropagation();
        const isOpen = popup.classList.contains('open');

        // Close other open popups
        document.querySelectorAll('.capsule-popup.open').forEach(p => {
          if (p !== popup) {
            p.classList.remove('open');
            p.previousElementSibling.classList.remove('active');
          }
        });

        popup.classList.toggle('open');
        toggle.classList.toggle('active');

        if (!isOpen) {
          // Scroll selected into view after opening
          setTimeout(() => {
            const selected = popup.querySelector('.capsule-option.selected');
            if (selected) {
              selected.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
            }
          }, 50);
        }
      };

      // Close on outside click
      const closeHandler = (e) => {
        if (!container.contains(e.target)) {
          popup.classList.remove('open');
        }
      };
      document.addEventListener('click', closeHandler);

      return container;
    }

    // Ê∏≤ÊüìË≥áÊñôÂàóË°® (Material Design 3 Card List with Calendar View & Month Grouping)
    let openCardId = null;
    let monthsToShowRequested = 1;
    function renderDataList(targetId = null) {
      if (targetId) openCardId = targetId;
      const container = document.getElementById('tableContainer');
      container.innerHTML = '';

      // Ê∑ªÂä†Ê°åÈù¢ÁâàÊòüÊúüÊ®ôÈ°å (Âè™È°ØÁ§∫‰∏ÄÊ¨°)
      if (window.innerWidth >= 1024) {
        const header = document.createElement('div');
        header.classList.add('calendar-header');
        ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
          const el = document.createElement('div');
          el.classList.add('calendar-weekday-label');
          el.textContent = day;
          header.appendChild(el);
        });
        const existingHeader = document.querySelector('.calendar-header');
        if (existingHeader) existingHeader.remove();
        container.parentNode.insertBefore(header, container);
      }

      // Ëã•Â∞öÊú™ËºâÂÖ•‰ªª‰ΩïË≥áÊñôÔºåÊ∏≤ÊüìÁ©∫ÁãÄÊÖãÂç°Áâá
      if (tableData.length === 0) {
        const payload = window.__OT_INIT_PAYLOAD__;
        const errorMsg = payload && payload.error ? payload.error : '';
        const isLocal = window.location.protocol === 'file:';

        const card = document.createElement('div');
        card.classList.add('data-card');
        card.style.textAlign = 'center';
        card.style.padding = '32px';
        card.style.cursor = 'pointer';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.alignItems = 'center';
        card.style.justifyContent = 'center';
        if (window.innerWidth >= 1024) card.style.gridColumn = '1 / -1';

        const statusIcon = errorMsg ? 'error' : (isLocal ? 'developer_mode' : 'upload_file');
        const statusTitle = errorMsg ? 'Data Loading Error' : (isLocal ? 'Development Mode' : 'No Data Available');
        const statusDesc = errorMsg ? `Error: ${errorMsg}` : (isLocal ? 'Local mock data loaded. Connect to GAS for live data.' : 'Tap here to import CSV or add a new entry above');

        card.innerHTML = `
          <div style="color: ${errorMsg ? 'var(--color-danger)' : 'var(--md-sys-color-primary)'}; margin-bottom: 16px;">
            <span class="material-symbols-outlined" style="font-size: 48px;">${statusIcon}</span>
          </div>
          <div style="font: var(--md-sys-typescale-title-medium); margin-bottom: 8px;">${statusTitle}</div>
          <div style="font: var(--md-sys-typescale-body-medium); color: var(--md-sys-color-on-surface-variant); max-width: 250px;">
            ${statusDesc}
          </div>
        `;

        card.addEventListener('click', () => {
          if (!errorMsg) {
            const importInput = document.getElementById('importCSVCard');
            if (importInput) importInput.click();
          }
        });

        container.appendChild(card);
        updateDashboard();
        return;
      }

      // 1. ÂÖàÊåâÊúà‰ªΩ„ÄåÁî±Êñ∞Ëá≥Ëàä„ÄçÊéíÂ∫èÔºå‰ΩÜÊúàÂàÜÂÖßÊó•Êúü„ÄåÁî±ËàäËá≥Êñ∞„ÄçÊéí (Calendar consistency)
      // Áî®ÂéüÂßã index ËøΩËπ§ÔºåÁ¢∫‰øù UI Áï∞ÂãïËÉΩÊ≠£Á¢∫ÂõûÊµÅÂà∞ tableData
      const sortedEntries = tableData.map((e, idx) => {
        e.originalIndex = idx;
        return e;
      }).sort((a, b) => {
        const dA = parseDateSafe(a.date);
        const dB = parseDateSafe(b.date);
        const monthA = dA.getFullYear() * 12 + dA.getMonth();
        const monthB = dB.getFullYear() * 12 + dB.getMonth();
        if (monthA !== monthB) return monthB - monthA; // Êúà‰ªΩÁî±Êñ∞Âà∞Ëàä
        return dA - dB; // Êó•ÊúüÁî±ËàäÂà∞Êñ∞
      });

      let lastMonthKey = '';

      // Pre-calculate Monthly Totals
      const monthlyOTMap = {};
      const monthlyTravelMap = {}; // New: Trave summary
      const monthSalaryMap = {};
      tableData.forEach(entry => {
        const d = parseDateSafe(entry.date);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;

        if (!monthlyOTMap[key]) monthlyOTMap[key] = 0;
        monthlyOTMap[key] += (Number(entry.otSalary) || 0);

        if (!monthlyTravelMap[key]) monthlyTravelMap[key] = 0;
        monthlyTravelMap[key] += (Number(entry.travel) || 0);

        if (entry.monthSLR) {
          const val = parseFloat(entry.monthSLR);
          if (val > 0) monthSalaryMap[key] = val;
        }
      });

      console.log('[OT] Redrawing data list with', tableData.length, 'entries');
      let renderedMonthsSet = new Set();
      let currentMonthGroup = null;
      sortedEntries.forEach((entry, displayIdx) => {
        const index = entry.originalIndex;
        // Month Grouping Logic
        const dateObj = parseDateSafe(entry.date);
        const currentMonthKey = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;

        if (!renderedMonthsSet.has(currentMonthKey)) {
          if (renderedMonthsSet.size >= monthsToShowRequested) return;
          renderedMonthsSet.add(currentMonthKey);
        }
        if (currentMonthKey !== lastMonthKey) {
          const monthHeader = document.createElement('div');
          monthHeader.classList.add('month-header');
          // monthHeader.classList.add('expand-wrapper'); // REMOVED: Headers should not be expand-wrappers themselves
          // Add data key for real-time updates
          monthHeader.dataset.monthKey = currentMonthKey;
          const isFirstMonth = (lastMonthKey === '');
          if (isFirstMonth) monthHeader.classList.add('open');
          monthHeader.style.cursor = 'pointer'; // Clickable
          monthHeader.title = "Click to toggle month view";

          const monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

          // Left: Title + Collapse Icon
          const leftWrapper = document.createElement('div');
          leftWrapper.style.display = 'flex';
          leftWrapper.style.alignItems = 'center';
          leftWrapper.style.gap = '8px';

          const expandIcon = document.createElement('span');
          expandIcon.classList.add('material-symbols-outlined');
          expandIcon.textContent = 'expand_more';
          expandIcon.style.transition = 'transform 0.2s';

          const title = document.createElement('span');
          title.textContent = `${monthNames[dateObj.getMonth()]} ${dateObj.getFullYear()} `;

          // 3. Contribution Calendar (Mini-grid)
          const monthEntries = tableData.filter(e => {
            if (!e.date) return false;
            const d = parseDateSafe(e.date);
            const mKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
            return mKey === currentMonthKey;
          });
          console.log(`[OT] Month ${currentMonthKey} has ${monthEntries.length} entries for grid`);

          const gridWrapper = document.createElement('div');
          gridWrapper.style.marginLeft = '12px'; // Gap from title
          gridWrapper.appendChild(renderContributionCalendar(currentMonthKey, monthEntries));

          leftWrapper.appendChild(title);
          leftWrapper.appendChild(gridWrapper); // Insert grid next to title
          leftWrapper.appendChild(expandIcon);

          // Right: Chips (OT Total + Salary)
          const rightWrapper = document.createElement('div');
          rightWrapper.style.display = 'flex';
          rightWrapper.style.gap = '8px';
          rightWrapper.style.alignItems = 'center';
          rightWrapper.style.paddingRight = '12px'; // Extra padding requested

          // 1. Monthly Travel Total (Blue)
          const travelTotalVal = Math.round(monthlyTravelMap[currentMonthKey] || 0);
          const travelChip = document.createElement('div');
          travelChip.classList.add('info-chip', 'blue', 'travel-chip');
          travelChip.innerHTML = `<span class="material-symbols-outlined" style="font-size: 1.1rem;">flight</span> <span class="privacy-hidden">${travelTotalVal}</span>`;

          // 2. Monthly OT Total (Yellow)
          const otTotalVal = Math.round(monthlyOTMap[currentMonthKey] || 0);
          const otChip = document.createElement('div');
          otChip.classList.add('info-chip', 'yellow', 'ot-chip');
          otChip.innerHTML = `<span class="material-symbols-outlined" style="font-size: 1.1rem;">more_time</span> <span class="privacy-hidden">+${otTotalVal}</span>`;

          // 3. Monthly Salary (Original)
          const salaryChip = document.createElement('div');
          salaryChip.classList.add('info-chip', 'salary-chip');
          salaryChip.style.background = '#fff9c4';
          salaryChip.style.color = '#5f5200';
          salaryChip.innerHTML = `<span class="material-symbols-outlined" style="font-size: 1.1rem;">monetization_on</span> <span class="privacy-hidden">${Math.round(monthSalaryMap[currentMonthKey] || 0)}</span>`;

          rightWrapper.appendChild(travelChip);
          rightWrapper.appendChild(otChip);
          rightWrapper.appendChild(salaryChip);

          monthHeader.appendChild(leftWrapper);
          monthHeader.appendChild(rightWrapper);
          container.appendChild(monthHeader);

          // Create Group Container (Wrapper)
          const thisMonthGroup = document.createElement('div');
          thisMonthGroup.classList.add('month-group', 'expand-wrapper');
          if (isFirstMonth) thisMonthGroup.classList.add('open');
          container.appendChild(thisMonthGroup);

          // Create Inner Grid/Content Container
          const innerGroup = document.createElement('div');
          innerGroup.classList.add('expand-inner');
          thisMonthGroup.appendChild(innerGroup);

          // Update global tracker for card appending
          currentMonthGroup = innerGroup; // Cards go into inner

          // Toggle Logic (Reference thisMonthGroup wrapper)
          monthHeader.addEventListener('click', () => {
            // Toggle class '.open'
            thisMonthGroup.classList.toggle('open');
            const isOpen = thisMonthGroup.classList.contains('open');
            expandIcon.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(-90deg)';
          });
          // Set initial rotation
          expandIcon.style.transform = isFirstMonth ? 'rotate(0deg)' : 'rotate(-90deg)';

          lastMonthKey = currentMonthKey;
        }

        const card = document.createElement('div');
        card.classList.add('data-card');
        const cardUniqueId = entry.__id || entry.date;
        if (openCardId === cardUniqueId) card.classList.add('expanded');

        // Desktop Calendar Alignment
        if (window.innerWidth >= 1024) {
          // Use Date object for reliable day index (0=Sun -> 1, 6=Sat -> 7)
          const col = dateObj.getDay() + 1;
          card.style.gridColumn = `${col} / span 1`;
        }

        // --- Header (Card Content) ---
        const header = document.createElement('div');
        header.classList.add('card-header');
        // Sunday Style Logic (Apply to CARD, not just header)
        if (dateObj.getDay() === 0) {
          card.classList.add('sunday');
        }

        // Primary Info: Date & Scoreboard
        const primaryInfo = document.createElement('div');
        primaryInfo.classList.add('card-primary-info');

        const dateWrapper = document.createElement('div');
        dateWrapper.classList.add('card-date-wrapper');

        const dd = String(dateObj.getDate()).padStart(2, '0');

        const dateDay = document.createElement('span');
        dateDay.classList.add('date-day');
        dateDay.textContent = dd;

        const dateWeekday = document.createElement('span');
        dateWeekday.classList.add('date-weekday');
        // Dynamic locale-independent weekday for display (e.g. 'Sun', 'Mon')
        dateWeekday.textContent = dateObj.toLocaleDateString('en-US', { weekday: 'short' });

        dateWrapper.appendChild(dateDay);
        dateWrapper.appendChild(dateWeekday);

        // OT Scoreboard Badge
        const otTotal = entry.totalOtHoursNumeric || (Number(entry.v167 || 0) + Number(entry.v134 || 0) + Number(entry.v166 || 0) + Number(entry.v267 || 0));
        const val = otTotal.toFixed(1); // One decimal precision

        const scoreboard = document.createElement('div');
        scoreboard.classList.add('scoreboard-badge');

        // Color Logic
        const numericVal = parseFloat(val);
        if (numericVal >= 2 && numericVal < 3) scoreboard.classList.add('green');
        else if (numericVal >= 3 && numericVal < 4) scoreboard.classList.add('yellow');
        else if (numericVal >= 4 && numericVal < 5) scoreboard.classList.add('orange');
        else if (numericVal >= 5 && numericVal < 6) scoreboard.classList.add('red');
        else if (numericVal >= 6) scoreboard.classList.add('purple');

        scoreboard.textContent = val;

        primaryInfo.appendChild(dateWrapper);
        primaryInfo.appendChild(scoreboard);

        // Secondary Info: Salary & Daily OT
        const secondaryInfo = document.createElement('div');
        secondaryInfo.classList.add('card-secondary-info');



        // Daily OT Salary
        const dailyTotalChip = document.createElement('div');
        dailyTotalChip.classList.add('info-chip', 'yellow', 'daily-total-chip'); // Added yellow class and specific class
        dailyTotalChip.id = `chip-daily-${index}`;
        dailyTotalChip.innerHTML = `<span class="privacy-hidden">+${Math.round(entry.total)}</span>`;

        // Travel Icon (Compact)
        const travelChip = document.createElement('div');
        travelChip.classList.add('info-chip', 'travel-chip');
        travelChip.id = `chip-travel-${index}`;

        // Ensure getCountryAbbr is reachable or define it locally if needed
        const countryCode = (typeof getCountryAbbr === 'function')
          ? getCountryAbbr(entry.travelCountry)
          : (entry.travelCountry && entry.travelCountry !== 'None' ? entry.travelCountry.slice(0, 2).toUpperCase() : '--');

        if (entry.travelCountry && entry.travelCountry !== 'None') {
          travelChip.classList.add('active'); // Blue background style
          travelChip.innerHTML = `<span>${countryCode}</span>`;
        } else {
          travelChip.innerHTML = `<span>--</span>`;
        }

        // secondaryInfo.appendChild(salaryChip); // Removed from card
        secondaryInfo.appendChild(dailyTotalChip);
        secondaryInfo.appendChild(travelChip);

        const expandIcon = document.createElement('span');
        expandIcon.classList.add('material-symbols-outlined', 'card-expand-icon');
        expandIcon.textContent = 'expand_more';

        header.appendChild(primaryInfo);
        header.appendChild(secondaryInfo);
        header.appendChild(expandIcon);

        // --- Body (Collapsible Wrapper) ---
        const bodyWrapper = document.createElement('div');
        bodyWrapper.className = 'expand-wrapper';
        if (openCardId === entry.date) bodyWrapper.classList.add('open');

        const body = document.createElement('div');
        body.classList.add('card-body', 'expand-inner');
        body.style.padding = '8px 16px'; // Reduced padding for shorter look

        // Hours Grid (Time Input: Hour & Minute)
        const grid = document.createElement('div');
        grid.classList.add('hours-grid');
        // Override grid layout for 2 columns (Hour, Min)
        grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
        grid.style.maxWidth = '200px';
        grid.style.margin = '0 auto 12px auto';

        // Initial Time
        const { h, m } = getReverseTime(entry);
        let currH = h;
        let currM = m;

        // Helper to update Entry & UI
        // Helper to update Entry & UI
        const updateTimeCalc = () => {
          // Update Entry Time String
          entry.endTime = `${String(currH).padStart(2, '0')}:${String(currM).padStart(2, '0')}`;

          // Calculate OT
          const res = calculateOvertime(currH, currM, entry.date, entry.isHoliday); // Pass isHoliday
          entry.v134 = res.v134;
          entry.v167 = res.v167;
          entry.v267 = res.v267;
          entry.v166 = res.v166; // Update v166 for holiday
          entry.totalOtHoursNumeric = res.total; // Consistent with Scoreboard

          // Update Local Card UI (Badge & Chips)
          // Scoreboard
          const otTotal = res.total;
          const val = otTotal.toFixed(1);
          if (scoreboard) {
            scoreboard.textContent = val;
            scoreboard.className = 'scoreboard-badge'; // Reset
            const numericVal = parseFloat(val);
            if (numericVal >= 2 && numericVal < 3) scoreboard.classList.add('green');
            else if (numericVal >= 3 && numericVal < 4) scoreboard.classList.add('yellow');
            else if (numericVal >= 4 && numericVal < 5) scoreboard.classList.add('orange');
            else if (numericVal >= 5 && numericVal < 6) scoreboard.classList.add('red');
            else if (numericVal >= 6) scoreboard.classList.add('purple');
          }

          /* 
             Fix: Call updateAll with skipRender=true to prevent destroying the DOM 
             and causing the card to "collapse" (reset to closed state).
          */
          updateAll(entry.date, true);

          // Daily Total Chip
          const dailyChip = document.getElementById(`chip-daily-${index}`);
          if (dailyChip) {
            dailyChip.innerHTML = `<span class="privacy-hidden">+${Math.round(entry.total || 0)}</span>`;
          }
        };

        // --- Hour Stepper ---
        const hourItem = document.createElement('div');
        hourItem.classList.add('hour-item');

        const hourLabel = document.createElement('div');
        hourLabel.classList.add('hour-label');
        hourLabel.textContent = 'Hour';

        const hourStepper = document.createElement('div');
        hourStepper.classList.add('smart-stepper');
        hourStepper.dataset.entryIndex = index;
        hourStepper.dataset.key = 'vH';
        if (currH >= 0) hourStepper.classList.add('has-value');
        hourStepper.textContent = String(currH).padStart(2, '0');

        // --- Minute Stepper ---
        const minItem = document.createElement('div');
        minItem.classList.add('hour-item');

        const minLabel = document.createElement('div');
        minLabel.classList.add('hour-label');
        minLabel.textContent = 'Min';

        const minStepper = document.createElement('div');
        minStepper.classList.add('smart-stepper');
        minStepper.dataset.entryIndex = index;
        minStepper.dataset.key = 'vM';
        if (currM >= 0) minStepper.classList.add('has-value');
        minStepper.textContent = String(currM).padStart(2, '0');

        const moveHDrag = (y) => {
          if (!hDrag) return;
          const delta = Math.floor((hDrag.startY - y) / 10);
          let newVal = (hDrag.startVal + delta) % 24;
          if (newVal < 0) newVal += 24;
          if (newVal !== currH) {
            currH = newVal;
            hourStepper.textContent = String(newVal).padStart(2, '0');
            updateTimeCalc();
          }
        };
        const endHDrag = () => {
          if (hDrag) {
            hourStepper.classList.remove('active');
            hDrag = null;
          }
        };

        const onHMove = (e) => moveHDrag(e.clientY);
        const textHMouseUp = () => {
          endHDrag();
          document.removeEventListener('mousemove', onHMove);
          document.removeEventListener('mouseup', textHMouseUp);
        };

        hourStepper.addEventListener('mousedown', (e) => {
          e.preventDefault();
          hDrag = { startY: e.clientY, startVal: currH };
          hourStepper.classList.add('active');
          document.addEventListener('mousemove', onHMove);
          document.addEventListener('mouseup', textHMouseUp);
        });

        const onHTouchMove = (e) => moveHDrag(e.touches[0].clientY);
        const touchHEnd = () => {
          endHDrag();
          document.removeEventListener('touchmove', onHTouchMove);
          document.removeEventListener('touchend', touchHEnd);
        };

        hourStepper.addEventListener('touchstart', (e) => {
          e.preventDefault();
          hDrag = { startY: e.touches[0].clientY, startVal: currH };
          hourStepper.classList.add('active');
          document.addEventListener('touchmove', onHTouchMove, { passive: false });
          document.addEventListener('touchend', touchHEnd);
        });

        // Min Drag
        const moveMDrag = (y) => {
          if (!mDrag) return;
          const steps = Math.floor((mDrag.startY - y) / 10);
          let newVal = (mDrag.startVal + (steps * 10)) % 60;
          if (newVal < 0) newVal += 60;
          if (newVal !== currM) {
            currM = newVal;
            minStepper.textContent = String(newVal).padStart(2, '0');
            updateTimeCalc();
          }
        };
        const endMDrag = () => {
          if (mDrag) {
            minStepper.classList.remove('active');
            mDrag = null;
          }
        };

        const onMMove = (e) => moveMDrag(e.clientY);
        const textMMouseUp = () => {
          endMDrag();
          document.removeEventListener('mousemove', onMMove);
          document.removeEventListener('mouseup', textMMouseUp);
        };

        minStepper.addEventListener('mousedown', (e) => {
          e.preventDefault();
          mDrag = { startY: e.clientY, startVal: currM };
          minStepper.classList.add('active');
          document.addEventListener('mousemove', onMMove);
          document.addEventListener('mouseup', textMMouseUp);
        });

        const onMTouchMove = (e) => moveMDrag(e.touches[0].clientY);
        const touchMEnd = () => {
          endMDrag();
          document.removeEventListener('touchmove', onMTouchMove);
          document.removeEventListener('touchend', touchMEnd);
        };

        minStepper.addEventListener('touchstart', (e) => {
          e.preventDefault();
          mDrag = { startY: e.touches[0].clientY, startVal: currM };
          minStepper.classList.add('active');
          document.addEventListener('touchmove', onMTouchMove, { passive: false });
          document.addEventListener('touchend', touchMEnd);
        });

        hourItem.appendChild(hourLabel);
        hourItem.appendChild(hourStepper);
        grid.appendChild(hourItem);

        minItem.appendChild(minLabel);
        minItem.appendChild(minStepper);
        grid.appendChild(minItem);

        // Create Icon Toggle Row (Holiday & Travel)
        const iconToggleRow = document.createElement('div');
        iconToggleRow.classList.add('icon-toggle-row');
        iconToggleRow.style.display = 'flex';
        iconToggleRow.style.gap = '12px';
        iconToggleRow.style.marginTop = '12px';
        iconToggleRow.style.justifyContent = 'center';

        // Holiday Icon Button
        const holidayBtn = document.createElement('div');
        holidayBtn.classList.add('circular-toggle-btn');
        holidayBtn.style.width = '44px';
        holidayBtn.style.height = '44px';
        holidayBtn.style.borderRadius = '12px';
        holidayBtn.style.display = 'flex';
        holidayBtn.style.alignItems = 'center';
        holidayBtn.style.justifyContent = 'center';
        holidayBtn.style.cursor = 'pointer';
        holidayBtn.style.background = entry.isHoliday ? 'rgba(255, 149, 0, 0.15)' : 'rgba(0,0,0,0.05)';
        holidayBtn.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';

        const holidayIcon = document.createElement('span');
        holidayIcon.classList.add('material-symbols-outlined');
        holidayIcon.textContent = entry.isHoliday ? 'holiday_village' : 'event_busy';
        holidayIcon.style.fontSize = '24px';
        holidayIcon.style.color = entry.isHoliday ? 'var(--color-warning)' : 'rgba(0,0,0,0.4)';

        holidayBtn.appendChild(holidayIcon);

        holidayBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          entry.isHoliday = !entry.isHoliday;
          updateTimeCalc();
          renderDataList(index);
        });

        // Leave Icon Button (New)
        const leaveBtn = document.createElement('div');
        leaveBtn.classList.add('circular-toggle-btn', 'leave');
        if (entry.isLeave) leaveBtn.classList.add('active');
        leaveBtn.style.width = '38px'; // Slightly smaller to fit 3 in a row
        leaveBtn.style.height = '38px';
        leaveBtn.style.borderRadius = '10px';
        leaveBtn.style.display = 'flex';
        leaveBtn.style.alignItems = 'center';
        leaveBtn.style.justifyContent = 'center';
        leaveBtn.style.cursor = 'pointer';
        leaveBtn.style.background = entry.isLeave ? 'rgba(186, 26, 26, 0.15)' : 'rgba(0,0,0,0.05)';
        leaveBtn.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';

        const leaveIcon = document.createElement('span');
        leaveIcon.classList.add('material-symbols-outlined');
        leaveIcon.textContent = entry.isLeave ? 'person_off' : 'person';
        leaveIcon.style.fontSize = '24px';
        leaveIcon.style.color = entry.isLeave ? '#ba1a1a' : 'rgba(0,0,0,0.4)';
        leaveBtn.appendChild(leaveIcon);

        // Leave Details UI (inside footer or body?)
        // Let's create a dedicated section for leave details in the card body if isLeave is true
        if (entry.isLeave) {
          const wrapper = document.createElement('div');
          wrapper.className = 'expandable-wrapper expanded'; // Standard expanded state for existing records
          const content = document.createElement('div');
          content.className = 'expandable-content';

          const leaveDetail = document.createElement('div');
          leaveDetail.style.display = 'flex';
          leaveDetail.style.flexDirection = 'column';
          leaveDetail.style.gap = '8px';
          leaveDetail.style.paddingTop = '8px';
          leaveDetail.style.width = '100%';

          const types = [
            'Áâπ‰ºë', '‰∫ãÂÅá', 'ÁóÖÂÅá', 'ÂÖ¨ÂÅá', 'Â©öÂÅá', 'ÂÖ¨ÂÇ∑ÂÅá', 'Âñ™ÂÅá',
            'ÊúâËñ™Áî¢ÂÅá', 'ÁÑ°Ëñ™Áî¢ÂÅá', 'Ë£ú‰ºë', 'Áî¢Ê™¢ÂÅá', 'Èô™Áî¢Ê™¢ÂèäÈô™Áî¢ÂÅá',
            'ÈßêÂú∞‰ºëÂÅá', 'ÁîüÁêÜÂÅá', 'ÂÆ∂Â∫≠ÁÖßÈ°ßÂÅá', '‰ΩèÈô¢ÁóÖÂÅá', 'ÂÅ•Ê™¢ÂÅá'
          ];
          const typeSelector = renderCapsuleSelector(types, entry.leaveType, (val) => {
            entry.leaveType = val;
            updateAll(index);
          });

          const amts = [
            { value: 1, label: '1.0 Â§©' }, { value: 0.5, label: '0.5 Â§©' }, { value: 0.125, label: '1 Â∞èÊôÇ' }, { value: 0.25, label: '2 Â∞èÊôÇ' }, { value: 0.375, label: '3 Â∞èÊôÇ' }, { value: 0.5, label: '4 Â∞èÊôÇ' }
          ];
          const amtSelector = renderCapsuleSelector(amts, entry.leaveAmount, (val) => {
            entry.leaveAmount = parseFloat(val);
            updateAll(index);
          });
          const amtToggle = amtSelector.querySelector('.capsule-toggle');
          const currentAmt = amts.find(a => a.value == entry.leaveAmount);
          if (amtToggle && currentAmt) amtToggle.textContent = currentAmt.label;

          leaveDetail.appendChild(typeSelector);
          leaveDetail.appendChild(amtSelector);
          content.appendChild(leaveDetail);
          wrapper.appendChild(content);
          body.appendChild(wrapper);

          // Trigger expansion after append if it was just toggled (hard to detect here, but updateAll(index) handles it)
        }

        leaveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          entry.isLeave = !entry.isLeave;
          if (entry.isLeave && !entry.leaveType) {
            entry.leaveType = 'Áâπ‰ºë';
            entry.leaveAmount = 1;
          }
          updateAll(index);
        });
        // Travel Icon Button
        const travelBtn = document.createElement('div');
        travelBtn.classList.add('circular-toggle-btn');
        travelBtn.style.width = '38px';
        travelBtn.style.height = '38px';
        travelBtn.style.borderRadius = '10px';
        travelBtn.style.display = 'flex';
        travelBtn.style.alignItems = 'center';
        travelBtn.style.justifyContent = 'center';
        travelBtn.style.cursor = 'pointer';
        travelBtn.style.position = 'relative'; // For badge
        const travels = ['None', ...Object.keys(getTravelRates())];
        const countryCodes = { 'Vietnam': 'VN', 'China': 'CN', 'India': 'IN', 'None': '' };
        const isTraveling = entry.travelCountry && entry.travelCountry !== 'None';
        travelBtn.style.background = isTraveling ? 'rgba(0, 122, 255, 0.15)' : 'rgba(0,0,0,0.05)';
        travelBtn.style.transition = 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';

        const travelIcon = document.createElement('span');
        travelIcon.classList.add('material-symbols-outlined');
        travelIcon.textContent = 'flight';
        travelIcon.style.fontSize = '24px';
        travelIcon.style.color = isTraveling ? 'var(--color-primary)' : 'rgba(0,0,0,0.4)';

        // Badge for Country Code
        if (isTraveling) {
          const badge = document.createElement('span');
          const code = countryCodes[entry.travelCountry] || (entry.travelCountry ? entry.travelCountry.slice(0, 2).toUpperCase() : '');
          badge.textContent = code;
          badge.style.position = 'absolute';
          badge.style.bottom = '4px';
          badge.style.right = '4px';
          badge.style.fontSize = '8px';
          badge.style.fontWeight = '800';
          badge.style.color = 'var(--color-primary)';
          badge.style.background = 'white';
          badge.style.padding = '1px 2px';
          badge.style.borderRadius = '3px';
          badge.style.lineHeight = '1';
          travelBtn.appendChild(badge);
        }

        travelBtn.appendChild(travelIcon);

        travelBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const currentIdx = travels.indexOf(entry.travelCountry || 'None');
          const nextIdx = (currentIdx + 1) % travels.length;
          entry.travelCountry = travels[nextIdx];

          // Fix: Call updateAll(index) to recalculate travel amount and update UI immediately
          updateAll(index);
        });

        holidayBtn.style.width = '38px';
        holidayBtn.style.height = '38px';
        holidayBtn.style.borderRadius = '10px';

        iconToggleRow.appendChild(holidayBtn);
        iconToggleRow.appendChild(leaveBtn);
        iconToggleRow.appendChild(travelBtn);
        body.appendChild(iconToggleRow);

        // Footer
        const footer = document.createElement('div');
        footer.classList.add('card-footer');

        const remark = document.createElement('div');
        remark.classList.add('remark-text');
        remark.contentEditable = "true";
        remark.style.cursor = "text";
        remark.style.outline = "none";
        remark.style.padding = "4px 8px";
        remark.style.borderRadius = "8px";
        remark.style.background = "rgba(0,0,0,0.03)";
        remark.textContent = entry.remark || 'No remarks';
        remark.addEventListener('blur', () => {
          entry.remark = remark.innerText.trim();
          updateAll(index, true); // Update but skip full re-render
        });

        const actions = document.createElement('div');
        actions.classList.add('card-actions');

        const actionBtn = document.createElement('button');
        actionBtn.classList.add('action-btn', 'delete');
        actionBtn.innerHTML = '<span class="material-symbols-outlined">delete</span>';
        actionBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Á¢∫ÂÆöÂà™Èô§?')) {
            deleteEntry(index);
          }
        });

        actions.appendChild(actionBtn);
        footer.appendChild(remark);
        footer.appendChild(actions);

        body.appendChild(grid);
        body.appendChild(footer);

        bodyWrapper.appendChild(body); // Add content to wrapper

        card.appendChild(header);
        card.appendChild(bodyWrapper); // Append wrapper to card
        // Append to Current Month Group instead of container directly
        if (currentMonthGroup) {
          currentMonthGroup.appendChild(card);
        } else {
          container.appendChild(card); // Fallback
        }

        // Expansion Logic (Animation)
        header.addEventListener('click', () => {
          if (openCardId === cardUniqueId) {
            openCardId = null;
            bodyWrapper.classList.remove('open');
            card.classList.remove('expanded');
          } else {
            // Close others
            document.querySelectorAll('.data-card.expanded').forEach(c => {
              c.classList.remove('expanded');
              const wrapper = c.querySelector('.expand-wrapper');
              if (wrapper) wrapper.classList.remove('open');
            });

            openCardId = cardUniqueId;
            bodyWrapper.classList.add('open');
            card.classList.add('expanded');
          }
        });
      });
      // Pagination: Load More Button
      const allMonths = Object.keys(monthlyOTMap).sort().reverse();
      if (allMonths.length > renderedMonthsSet.size) {
        const loadMoreRow = document.createElement('div');
        loadMoreRow.style.padding = '32px 0';
        loadMoreRow.style.display = 'flex';
        loadMoreRow.style.justifyContent = 'center';

        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.className = 'promo-action-btn load-more-btn';
        loadMoreBtn.style.padding = '12px 32px';
        loadMoreBtn.style.borderRadius = '24px';
        loadMoreBtn.style.fontWeight = '700';
        loadMoreBtn.innerHTML = `<span>ËÆÄÂèñÊõ¥Â§ö Load More</span><span style="margin-left:8px; opacity:0.6; font-size:0.8rem;">(${allMonths.length - renderedMonthsSet.size} Ââ©È§ò)</span>`;
        loadMoreBtn.onclick = () => {
          monthsToShowRequested += 3;
          renderDataList();
        };
        loadMoreRow.appendChild(loadMoreBtn);
        container.appendChild(loadMoreRow);
      }

      updateDashboard();
    }
    /* Logic removed */


    // === Â∞áÁõÆÂâçË°®Ê†ºË≥áÊñôÊï¥ÁêÜÊàêÂèØÂØ´Âõû Sheet ÁöÑÁµêÊßã ===
    function buildSheetPayload() {
      const headers = [
        'date',
        'weekday',
        '1.67',
        '1.34',
        '2.0',
        '2.67',
        'OT hr SUM',
        'Base',
        'Travel',
        'OT Salary',
        'Total',
        'Month SLR',
        'Remark',
        'isLeave',
        'isHoliday',
        'travelCountry',
        'endTime',
        'leaveType',
        'leaveAmount'
      ];
      const rows = tableData.map((entry) => [
        entry.date || '',
        entry.weekday || getWeekdayChar(entry.date || ''),
        Number(entry.v167 || 0),
        Number(entry.v134 || 0),
        Number(entry.v166 || 0),
        Number(entry.v267 || 0),
        String(entry.otSum || 0),
        String(entry.base || 0),
        String(entry.travel || 0),
        String(entry.otSalary || 0),
        String(entry.total || 0),
        String(entry.monthSLR || 0),
        entry.remark || '',
        entry.isLeave ? 'TRUE' : 'FALSE',
        entry.isHoliday ? 'TRUE' : 'FALSE',
        entry.travelCountry || 'None',
        entry.endTime || '',
        entry.leaveType || '',
        entry.leaveAmount || 0
      ]);
      return { headers, rows };
    }

    // === Áµ±Ë®àÁî®Â∑•ÂÖ∑ÂáΩÂºèÔºàÊñπ‰æøÂÖ∂‰ªñÂú∞ÊñπÈáçÁî®Ôºâ ===
    function getTotalRecordCount() {
      return tableData.length;
    }

    function getLatestMonthKey() {
      let latestDate = null;
      tableData.forEach((entry) => {
        if (!entry.date) return;
        const d = parseDateSafe(entry.date);
        if (!latestDate || d > latestDate) {
          latestDate = d;
        }
      });
      if (!latestDate) return '';
      const yyyy = latestDate.getFullYear();
      const mm = String(latestDate.getMonth() + 1).padStart(2, '0');
      return `${yyyy}-${mm}`;
    }

    function getMonthlyTravelDays(monthKey) {
      if (!monthKey) return 0;
      return tableData.filter(
        (entry) => entry.date && entry.date.slice(0, 7) === monthKey
      ).length;
    }

    function getMonthlyOtHours(monthKey) {
      if (!monthKey) return 0;
      let sum = 0;
      tableData.forEach((entry) => {
        if (!entry.date || entry.date.slice(0, 7) !== monthKey) return;
        sum +=
          (parseFloat(entry.v167) || 0) +
          (parseFloat(entry.v134) || 0) +
          (parseFloat(entry.v166) || 0) +
          (parseFloat(entry.v267) || 0);
      });
      return sum;
    }

    function getMonthlySalary(monthKey) {
      if (!monthKey) return 0;
      const found = tableData.find(
        (entry) => entry.date && entry.date.slice(0, 7) === monthKey && entry.monthSLR
      );
      return found ? parseFloat(found.monthSLR) || 0 : 0;
    }

    function getMonthlyAverageDailySalary(monthKey) {
      if (!monthKey) return 0;
      let sum = 0;
      let count = 0;
      tableData.forEach((entry) => {
        if (!entry.date || entry.date.slice(0, 7) !== monthKey) return;
        const total = parseFloat(entry.total || 0);
        if (!isNaN(total)) {
          sum += total;
          count += 1;
        }
      });
      if (!count) return 0;
      return sum / count;
    }

    // ÂÖ±Áî®ÔºöÂèñÂæóÁï∂ÊúàÊëòË¶ÅË®äÊÅØ
    function getMonthlySummaryText() {
      const totalCount = getTotalRecordCount();
      const monthKey = getLatestMonthKey();

      if (!monthKey) {
        return `Â∑≤Ë®òÈåÑ ${totalCount} Á≠ÜË≥áÊñô`;
      }

      const travelDays = getMonthlyTravelDays(monthKey);
      const otHours = getMonthlyOtHours(monthKey);
      const monthSalary = getMonthlySalary(monthKey);
      const avgDaily = getMonthlyAverageDailySalary(monthKey);

      const [year, month] = monthKey.split('-');
      const prettyMonth = `${year}/${month}`;

      const msgLines = [
        `Â∑≤Ë®òÈåÑ ${totalCount} Á≠ÜË≥áÊñô`,
        `${prettyMonth} Â∑≤Âá∫Â∑Æ ${travelDays} Â§©`,
        `${prettyMonth} Â∑≤Âä†Áè≠ ${otHours.toFixed(2)} Â∞èÊôÇ`,
        `${prettyMonth} ÊúàËñ™Ôºö${Math.round(monthSalary)}`,
        `${prettyMonth} Âπ≥ÂùáÊó•Ëñ™ÔºöÁ¥Ñ ${Math.round(avgDaily)}`,
      ];

      return msgLines.join('\n');
    }

    // === Ëß∏ÁôºÂØ´Âõû Google Sheet ===
    async function saveToSheet() {
      const payload = buildSheetPayload();

      // Áõ¥Êé•ÂòóË©¶ÈÄèÈÅé google.script.run ÂëºÂè´ÂæåÁ´ØÔºõËã•‰∏çÂ≠òÂú®ÂâáË¶ñÁÇ∫Á¥îÂâçÁ´ØÁí∞Â¢É
      try {
        if (!google || !google.script || !google.script.run) {
          throw new Error('google.script.run not available');
        }
      } catch (e) {
        alert('Ë´ãÂæû Apps Script Á∂≤È†ÅÁâàÊú¨ÈñãÂïüÔºåÊâçËÉΩÊääË≥áÊñôÂØ´Âõû Google Sheet„ÄÇ\nÁõÆÂâçÈÄôÂÄãÈ†ÅÈù¢ÂÉÖ‰ΩúÁÇ∫ÂâçÁ´ØË©¶ÁÆó‰ΩøÁî®„ÄÇ');
        showNotification('‚ùå ‰∏äÂÇ≥Â§±ÊïóÔºöÁÑ°Ê≥ïÈÄ£Á∑öÂà∞ Google Apps Script Áí∞Â¢É', true);
        return;
      }

      return new Promise((resolve, reject) => {
        const btn = document.getElementById('saveToSheetBtn');
        let progressInterval = null;

        if (btn) {
          btn.classList.add('loading');
          let pText = btn.querySelector('.progress-text');
          if (!pText) {
            pText = document.createElement('span');
            pText.className = 'progress-text';
            btn.appendChild(pText);
          }

          let percent = 0;
          pText.textContent = '0%';
          progressInterval = setInterval(() => {
            if (percent < 98) {
              const increment = percent < 80 ? (Math.floor(Math.random() * 8) + 2) : (Math.floor(Math.random() * 2) + 1);
              percent += increment;
              if (percent > 98) percent = 98;
              pText.textContent = `${percent}%`;
            }
          }, 100);
        }

        // Persist Settings First
        const settingsPayload = {
          salaryHistory: globalSettings.salaryHistory,
          travelRates: globalSettings.travelRates,
          usdRate: globalSettings.usdRate,
          rules: globalSettings.rules
        };

        if (typeof google !== 'undefined' && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler(() => {
              console.log('[OT] Settings persisted to sheet.');
              storage.set('globalSettings', JSON.stringify(settingsPayload));
            })
            .saveSettings(settingsPayload);
        }

        google.script.run
          .withSuccessHandler((res) => {
            if (progressInterval) clearInterval(progressInterval);
            if (btn) {
              const pText = btn.querySelector('.progress-text');
              if (pText) pText.textContent = '100%';

              // Ensure user sees 100% before resetting
              setTimeout(() => {
                btn.classList.remove('loading');
                if (res.ok) {
                  console.log('[OT] saveOvertimeData OK:', res);
                  const summary = getMonthlySummaryText();
                  showNotification(`‚úÖ Â∑≤ÂêåÊ≠•Ëá≥ ${res.sheetName || 'Ë©¶ÁÆóË°®'}\n${summary}`);
                  resolve(res);
                } else {
                  const errMsg = res.error || 'Êú™Áü•ÈåØË™§';
                  alert('ÂØ´Âõû Google Sheet Â§±Êïó„ÄÇ\nÂéüÂõ†Ôºö' + errMsg);
                  showNotification('‚ùå ‰∏äÂÇ≥Â§±ÊïóÔºö' + errMsg, true);
                  reject(res);
                }
              }, 700);
            }
          })
          .withFailureHandler((err) => {
            if (progressInterval) clearInterval(progressInterval);
            if (btn) btn.classList.remove('loading');
            console.error('[OT] saveOvertimeData FAIL:', err);

            const errMsg = err && (err.message || err.toString()) ? (err.message || err.toString()) : 'Êú™Áü•ÈåØË™§';
            alert('ÂØ´Âõû Google Sheet Â§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ\nÂéüÂõ†Ôºö' + errMsg);
            showNotification('‚ùå ‰∏äÂÇ≥Â§±ÊïóÔºö' + errMsg, true);

            reject(err);
          })
          .saveOvertimeData(payload);
      });
    }

    // === Contribution Calendar Rendering ===
    function renderContributionCalendar(monthKey, monthEntries) {
      console.log(`[OT] renderContributionCalendar called for ${monthKey}`, monthEntries);
      const grid = document.createElement('div');
      grid.className = 'contribution-grid';

      // Get days in month
      const [year, month] = monthKey.split('-').map(Number);
      const daysInMonth = new Date(year, month, 0).getDate();

      // Create a map of date -> { ot, travel, presence, leave }
      const statMap = {};
      monthEntries.forEach(e => {
        // [Audit Fix] Robust date parsing (avoid timezone offset issues)
        const dStr = e.date.split('-')[2];
        const d = parseInt(dStr, 10);
        if (!statMap[d]) statMap[d] = { ot: 0, travel: 0, presence: 0, leave: 0 };

        statMap[d].ot += (parseFloat(e.otSum) || 0);
        statMap[d].travel += (parseFloat(e.travel) || 0);
        statMap[d].presence += (parseFloat(e.base) || 0);
        if (e.isLeave) statMap[d].leave += 1;
      });

      // Render all days of the month in a single row
      for (let i = 1; i <= daysInMonth; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';

        const stats = statMap[i] || { ot: 0, travel: 0, presence: 0 };
        const ot = stats.ot;
        const travel = stats.travel;
        const presence = stats.presence;

        const isNeumo = document.documentElement.getAttribute('data-theme') === 'neumorphic';
        if (stats.leave > 0) {
          cell.style.background = isNeumo ? '#c4c8cc' : '#8B0000';
        } else if (travel > 0) {
          if (ot >= 4) cell.style.background = isNeumo ? '#5d6268' : '#004ea2';
          else if (ot >= 2) cell.style.background = isNeumo ? '#7d8288' : '#007AFF';
          else if (ot > 0) cell.style.background = isNeumo ? '#9da1a6' : '#80bdff';
          else cell.style.background = isNeumo ? '#bdc2c6' : '#e0f0ff';
        } else if (ot >= 4) {
          cell.style.background = isNeumo ? '#6d7276' : '#004d00';
        } else if (ot >= 2) {
          cell.style.background = isNeumo ? '#8d9296' : '#006400';
        } else if (ot > 0 || presence > 0) {
          cell.style.background = isNeumo ? '#bdc2c6' : '#7CFC00';
        } else {
          cell.style.background = isNeumo ? '#e0e5e9' : '#e0e0e0';
        }

        cell.title = `${monthKey}-${i}: ${Math.round(ot)} OT, ${Math.round(presence)} Presence, ${Math.round(travel)} Travel`;
        grid.appendChild(cell);
      }

      return grid;
    }

    // ÂåØÂá∫ CSV
    document
      .getElementById('exportCSVCard')
      .addEventListener('click', () => {
        let csv =
          'date,weekday,1.67,1.34,2.0,2.67,OT hr SUM,Base,Travel,OT Salary,Total,Month SLR,Remark,isLeave,isHoliday,travelCountry,endTime,leaveType,leaveAmount\n';
        tableData.forEach((entry) => {
          csv +=
            [
              entry.date,
              entry.weekday,
              entry.v167,
              entry.v134,
              entry.v166,
              entry.v267,
              entry.otSum,
              entry.base,
              entry.travel,
              entry.otSalary,
              entry.total,
              entry.monthSLR,
              entry.remark ? `"${entry.remark.replace(/"/g, '""')}"` : '',
              entry.isLeave ? 'TRUE' : 'FALSE',
              entry.isHoliday ? 'TRUE' : 'FALSE',
              entry.travelCountry || 'None',
              entry.endTime || '',
              entry.leaveType || '',
              entry.leaveAmount || 0
            ].join(',') + '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);

        // ‰ª•Êú¨Âú∞ÊôÇÈñìÁî¢Áîü yyyymmddÔºà‰æãÂ¶ÇÔºö20251112Ôºâ
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const filename = `overtime_${yyyy}${mm}${dd}.csv`;

        link.download = filename;
        link.click();
      });

    // ÂåØÂÖ• CSV
    document
      .getElementById('importCSVCard')
      .addEventListener('change', function (e) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = function (event) {
          const text = event.target.result;
          parseCSV(text);
          updateAll();
        };
        reader.readAsText(file);
      });

    function parseCSV(text) {
      const lines = text
        .split('\n')
        .filter((line) => line.trim() !== '');
      if (lines.length <= 1) return;

      tableData = lines.slice(1).map((line) => {
        // Handle potential commas in remarks by using a smarter split if needed, 
        // but for now simple split and join for remaining columns if remark has commas is better.
        // Actually a proper CSV parser would be better, but let's stick to consistent indices for now.
        const cols = line.split(',');
        return {
          date: cols[0],
          v167: parseFloat(cols[2]) || 0,
          v134: parseFloat(cols[3]) || 0,
          v166: parseFloat(cols[4]) || 0,
          v267: parseFloat(cols[5]) || 0,
          remark: (cols[12] || '').replace(/^"|"$/g, ''),
          isLeave: cols[13] === 'TRUE',
          isHoliday: cols[14] === 'TRUE',
          travelCountry: cols[15] || 'None',
          endTime: cols[16] || '',
          leaveType: cols[17] || '',
          leaveAmount: parseFloat(cols[18]) || 0
        };
      });
    }

    // Êõ¥Êñ∞ Dashboard Á∏ΩË®à
    function updateDashboard() {
      let totalOT = 0,
        totalTravel = 0,
        totalOTSalary = 0,
        totalCost = 0;

      const travelDays = tableData.filter(e => {
        const trv = parseFloat(e.travel || 0);
        return trv > 0;
      }).length;

      tableData.forEach((entry) => {
        const isLeave = !!entry.isLeave;
        const otHours = isLeave ? 0 : (
          (parseFloat(entry.v167) || 0) +
          (parseFloat(entry.v134) || 0) +
          (parseFloat(entry.v166) || 0) +
          (parseFloat(entry.v267) || 0)
        );
        totalOT += otHours;
        totalTravel += parseFloat(entry.travel || 0);
        totalOTSalary += parseFloat(entry.otSalary || 0);
        totalCost += parseFloat(entry.total || 0);
      });

      const items = [
        { id: 'travelDays', val: travelDays },
        { id: 'totalOT', val: totalOT.toFixed(1) },
        { id: 'totalTravel', val: Math.round(totalTravel) },
        { id: 'totalOTSalary', val: Math.round(totalOTSalary) },
        { id: 'totalCost', val: Math.round(totalCost) }
      ];

      items.forEach(item => {
        const el = document.getElementById(item.id);
        if (el) {
          el.classList.add('privacy-hidden');
          setAnimatedNumber(el, String(item.val));
        }
      });
    }

    // Toggle Dashboard Card
    global.toggleDashboardCard = function () {
      const body = document.getElementById('dashboardBody');
      const icon = document.getElementById('dashboardExpandIcon');
      if (!body || !icon) return;
      body.classList.toggle('open');
      const isOpen = body.classList.contains('open');
      icon.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(-90deg)';
      icon.textContent = isOpen ? 'expand_less' : 'expand_more';
    };

    global.toggleToolboxCard = function () {
      const body = document.getElementById('toolboxBody');
      const icon = document.getElementById('toolboxExpandIcon');
      if (!body || !icon) return;
      body.classList.toggle('open');
      const isOpen = body.classList.contains('open');
      icon.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(-90deg)';
      icon.textContent = isOpen ? 'expand_less' : 'expand_more';
    };

    // Privacy Mode Global Toggle
    function togglePrivacyMode() {
      document.body.classList.toggle('privacy-mode');
      const btn = document.getElementById('privacyToggleBtn');
      if (btn) {
        const isActive = document.body.classList.contains('privacy-mode');
        btn.classList.toggle('active', isActive);
        const icon = btn.querySelector('.material-symbols-outlined');
        if (icon) {
          icon.textContent = isActive ? 'visibility_off' : 'visibility';
        }
      }
    }

    function toggleTheme() {
      const html = document.documentElement;
      const current = html.getAttribute('data-theme');
      const next = current === 'neumorphic' ? 'default' : 'neumorphic';
      html.setAttribute('data-theme', next);
      storage.set('appTheme', next);
      showNotification(next === 'neumorphic' ? 'üé® Â∑≤ÂàáÊèõËá≥Êñ∞Êì¨ÊÖã‰∏ªÈ°å' : '‚ú® Â∑≤ÂàáÊèõËá≥ÁéªÁíÉÊì¨ÊÖã‰∏ªÈ°å');

      // Dynamic theme update for charts and colors
      if (typeof initCharts === 'function') initCharts(true);
      if (typeof updateAll === 'function') updateAll();
      setTimeout(() => { if (typeof updateCharts === 'function') updateCharts(); }, 300);
    }

    function initTheme() {
      const saved = storage.get('appTheme') || 'neumorphic';
      document.documentElement.setAttribute('data-theme', saved);
    }
    global.togglePrivacyMode = togglePrivacyMode;
    global.toggleTheme = toggleTheme;

    // Áï∂ÂåØÁéáËº∏ÂÖ•ËÆäÊõ¥ÊôÇÔºåËá™ÂãïÈáçÊñ∞Ë®àÁÆó
    const usdRateEl = document.getElementById('usdRate');
    if (usdRateEl) {
      usdRateEl.addEventListener('input', () => {
        updateAll();
      });
    }

    // === Google Sheet Áõ∏ÈóúÂ∑•ÂÖ∑ÔºàHtmlService ÁâàÔºöÂÑ™ÂÖàËµ∞ google.script.runÔºâ ===

    // === Google Sheet Áõ∏ÈóúÂ∑•ÂÖ∑ÔºàHtmlService ÁâàÔºöÁõ¥Êé•ÂêÉ Template Ê≥®ÂÖ•ÁöÑÂàùÂßãË≥áÊñôÔºâ ===
    let isLoadingFromSheet = false;
    async function loadFromSheet() {
      console.log('[OT] ÂòóË©¶ËºâÂÖ•Ë≥áÊñô...');
      if (isLoadingFromSheet) return;
      isLoadingFromSheet = true;
      try {
        let payload = window.__OT_INIT_PAYLOAD__;
        console.log('[OT] ÂàùÂßã Payload ÁãÄÊÖã:', payload ? 'Â∑≤ËÆÄÂèñ' : 'Êú™ËÆÄÂèñ');

        // Â¶ÇÊûúÊòØÊú¨Âú∞ÈñãÁôºÁí∞Â¢É‰∏îÊ≤íÊúâ PayloadÔºåÊèê‰æõÊ®°Êì¨Ë≥áÊñô
        if (!payload && (window.location.protocol === 'file:' || !window.google)) {
          console.log('[OT] Êú¨Âú∞Áí∞Â¢ÉÂÅµÊ∏¨ÔºöËºâÂÖ•Ê®°Êì¨Ë≥áÊñô (Dev Mode)');
          payload = {
            data: [
              { date: '2025-12-01', v167: 1, v134: 0, v166: 0, v267: 0, remark: 'Êú¨Âú∞Ê∏¨Ë©¶Ë≥áÊñô A', travelCountry: 'Vietnam' },
              { date: '2025-12-02', v167: 0, v134: 3, v166: 0, v267: 0, remark: 'Êú¨Âú∞Ê∏¨Ë©¶Ë≥áÊñô B', travelCountry: 'None' }
            ]
          };
          window.__OT_INIT_PAYLOAD__ = payload;
        }
        let rows = [];
        if (Array.isArray(payload)) {
          rows = payload;
        } else if (payload && Array.isArray(payload.data)) {
          rows = payload.data;
        }

        console.log('[OT] ÊúÄÁµÇ rows Ë≥áÊñôÁ≠ÜÊï∏:', rows ? rows.length : 0);

        if (rows && rows.length > 0) {
          console.log('[OT] ÈñãÂßãÂü∑Ë°å initTableFromPayload');
          initTableFromPayload({ data: rows });
          showNotification(`‚úÖ Â∑≤ËºâÂÖ• ${rows.length} Á≠ÜË≥áÊñô`);
        } else {
          // [Audit Fix] Try local cache if Template payload is empty
          const cached = storage.get('overtimeData');
          if (cached) {
            const cachedRows = JSON.parse(cached);
            if (cachedRows.length > 0) {
              console.log('[OT] ‰ΩøÁî®Êú¨Âú∞Âø´ÂèñË≥áÊñôÂàùÂßãÂåñ');
              initTableFromPayload({ data: cachedRows });
              showNotification(`‚úÖ Â∑≤ÂæûÊú¨Âú∞Âø´ÂèñËºâÂÖ• ${cachedRows.length} Á≠ÜË≥áÊñô`);
              return; // Successfully loaded from cache
            }
          }

          console.warn('[OT] Template Ë≥áÊñôÁÇ∫Á©∫ÔºåÂòóË©¶ÈÄèÈÅé API ÈáçÊñ∞ÊäìÂèñ...');
          // Fallback: ÂòóË©¶Áî® google.script.run ÊäìÂèñ
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run
              .withSuccessHandler((res) => {
                console.log('[OT] API ÊäìÂèñÊàêÂäü:', res);
                if (res && res.data && res.data.length > 0) {
                  initTableFromPayload(res);
                  showNotification(`‚úÖ ÈÄèÈÅé API ËºâÂÖ• ${res.data.length} Á≠ÜË≥áÊñô`);
                } else {
                  console.warn('[OT] API Ë≥áÊñô‰πüÁÇ∫Á©∫');
                  renderDataList(); // È°ØÁ§∫Á©∫Ë°®
                  showNotification('‚ö†Ô∏è ÁÑ°Ê≥ïËÆÄÂèñË≥áÊñôÔºåË´ãÊ™¢Êü• Google Sheet ÊòØÂê¶ÊúâË≥áÊñô', true);
                }
              })
              .withFailureHandler((err) => {
                console.error('[OT] API ÊäìÂèñÂ§±Êïó:', err);
                renderDataList(); // È°ØÁ§∫Á©∫Ë°®
                showNotification('‚ùå Ë≥áÊñôËÆÄÂèñÂ§±ÊïóÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÊàñÊ¨äÈôê', true);
              })
              .getOvertimeData();
          } else {
            console.warn('[OT] ÁÑ°Ê≥ï‰ΩøÁî® google.script.runÔºåÈ°ØÁ§∫Á©∫Ë°®');
            renderDataList();
            syncTravelToggleUI();
          }
        }

        // --- Fetch Settings from Sheet ---
        if (typeof google !== 'undefined' && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler((res) => {
              if (res && res.ok && res.data && Object.keys(res.data).length > 0) {
                console.log('[OT] Settings loaded from sheet:', res.data);
                globalSettings = { ...globalSettings, ...res.data };
                // Apply UI changes
                if (document.getElementById('usdRate')) {
                  document.getElementById('usdRate').value = globalSettings.usdRate;
                }
                updateAll();
              }
            })
            .getSettings();
        }
      } catch (err) {
        console.error('[OT] loadFromSheet ÁôºÁîüÈåØË™§:', err);
        renderDataList();
        syncTravelToggleUI();
        showNotification('‚ùå ÂàùÂßãÂåñÂ§±Êïó: ' + err.message, true);
      } finally {
        isLoadingFromSheet = false;
      }
    }

    // === Ë®∫Êñ∑Â∑•ÂÖ∑ÔºöÊâãÂãïÊ™¢Êü•ÈÄ£Á∑öËàáË≥áÊñô ===
    function runDiagnostics() {
      showNotification('Ê≠£Âú®Ë®∫Êñ∑ÈÄ£Á∑öËàáË≥áÊñô...');
      if (typeof google === 'undefined' || !google.script || !google.script.run) {
        alert('‚ùå Ë®∫Êñ∑Â§±ÊïóÔºöÊú™ÂÅµÊ∏¨Âà∞ Google Apps Script Áí∞Â¢É„ÄÇ\nË´ãÁ¢∫‰øùÊÇ®ÊòØÂú® Google ÈÉ®ÁΩ≤ÂæåÁöÑÁ∂≤ÂùÄÔºàscript.google.comÔºâ‰∏≠Âü∑Ë°åÊ≠§ÂäüËÉΩ„ÄÇ\nÊú¨Âú∞È†êË¶ΩÊ®°Âºè‰∏ãÁÑ°Ê≥ïÂëºÂè´ÂæåÁ´Ø API„ÄÇ');
        return;
      }

      google.script.run
        .withSuccessHandler((res) => {
          console.log('[OT Diagnostics] Response:', res);
          let msg = '‚úÖ ÈÄ£Á∑öÊàêÂäüÔºÅ\n\n';
          if (res && res.data) {
            msg += `Ë≥áÊñôÁ≠ÜÊï∏: ${res.data.length}\n`;
            if (res.data.length > 0) {
              msg += `Á¨¨‰∏ÄÁ≠ÜÊó•Êúü: ${res.data[0].date || 'ÁÑ°'}\n`;
              msg += `Ë©¶ÁÆóË°®ÁõÆÂâçÂÅµÊ∏¨Âà∞ÂÖßÂÆπÔºåË´ãÊ™¢Êü•ÁØ©ÈÅ∏Âô®ÊàñÈö±ÁßÅÊ®°ÂºèÊòØÂê¶Â∞éËá¥È°ØÁ§∫Á©∫ÁôΩ„ÄÇ\n`;
            } else {
              if (res.sheetNames) {
                msg += `ÂÅµÊ∏¨Âà∞ÁöÑÂ∑•‰ΩúË°®: ${res.sheetNames.join(', ')}\n`;
              }
              if (res.error) {
                msg += `ÂæåÁ´ØÂõûÂ†±ÈåØË™§: ${res.error}\n`;
              } else {
                msg += 'ÊèêÁ§∫: ÁõÆÂâçÈÄ£Á∑öÂà∞ÁöÑË©¶ÁÆóË°®ÂÖßÂÆπÊòØÁ©∫ÁöÑ (Âè™ÊúâÊ®ôÈ°åÂàó)ÔºåË´ãÊ™¢Êü•Â∑•‰ΩúË°®ÂÖßÂÆπ„ÄÇ\n';
              }
            }
          } else {
            msg += '‚ö†Ô∏è Êî∂Âà∞ÁÑ°ÊïàÁöÑÂõûÂÇ≥Ê†ºÂºè„ÄÇ';
          }
          alert(msg);
        })
        .withFailureHandler((err) => {
          console.error('[OT Diagnostics] Error:', err);
          alert('‚ùå API ÂëºÂè´Â§±Êïó: ' + err);
        })
        .getOvertimeData();
    }

    function initTableFromPayload(payload) {
      const rows = payload && payload.data ? payload.data : [];
      tableData = rows.map((row, index) => {
        try {
          let rawDate = row.date;

          // Apps Script ÈÄèÈÅé google.script.run ÂÇ≥ÈÅé‰æÜÔºådate ÂèØËÉΩÊòØ Date Áâ©‰ª∂Ôºå‰πüÂèØËÉΩÊòØÂ≠ó‰∏≤
          // Normalize date to YYYY-MM-DD
          function normalizeDate(val) {
            if (!val) return '';
            // If it's already a Date object
            if (val instanceof Date) {
              const yyyy = val.getFullYear();
              const mm = String(val.getMonth() + 1).padStart(2, '0');
              const dd = String(val.getDate()).padStart(2, '0');
              return `${yyyy}-${mm}-${dd}`;
            }

            const s = val.toString().trim();

            // Detect ISO strings like 2025-12-23T17:00:00.000Z
            // If it has T and Z, parse normally and get LOCAL date parts
            if (s.includes('T') && s.includes('Z')) {
              const d = parseDateSafe(s);
              if (!isNaN(d.getTime())) {
                const yyyy = d.getFullYear(); // Local Year
                const mm = String(d.getMonth() + 1).padStart(2, '0'); // Local Month
                const dd = String(d.getDate()).padStart(2, '0'); // Local Date
                return `${yyyy}-${mm}-${dd}`;
              }
            }

            // Simple YYYY-MM-DD or YYYY/MM/DD
            const match = s.match(/^(\d{4})[/\-](\d{1,2})[/\-](\d{1,2})/);
            if (match) {
              const yyyy = match[1];
              const mm = match[2].padStart(2, '0');
              const dd = match[3].padStart(2, '0');
              return `${yyyy}-${mm}-${dd}`;
            }

            // Fallback: replace dash with slash to avoid UTC interpretation for short date strings
            const dateStr = s.includes('-') && !s.includes(':') ? s.replace(/-/g, '/') : s;
            const d = parseDateSafe(dateStr);
            if (isNaN(d.getTime())) return s.slice(0, 10);
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
          }
          rawDate = normalizeDate(rawDate);

          if (index === 0) {
            console.log('[OT] Diagnostic - First Row Keys:', Object.keys(row));
            console.log('[OT] Diagnostic - First Row Data:', row);
          }
          const v167 = safeParseFloat(row.v167 ?? row['1.67'] ?? 0);
          const v134 = safeParseFloat(row.v134 ?? row['1.34'] ?? 0);
          const v166 = safeParseFloat(row.v166 ?? row['2'] ?? row['2.0'] ?? row['1.66'] ?? 0);
          const v267 = safeParseFloat(row.v267 ?? row['2.67'] ?? 0);

          const baseRaw = row.base ?? row.Base ?? '';
          const travelRaw = row.travel ?? row.Travel ?? '';
          const otSalaryRaw = row.otSalary ?? row['OT Salary'] ?? '';
          const totalRaw = row.total ?? row.Total ?? '';
          const monthSlrRaw = row.monthSLR ?? row['Month SLR'] ?? '';
          const otSumRaw = row.otSum ?? row['OT hr SUM'] ?? '';
          const remarkRaw = row.remark ?? row.Remark ?? '';

          const travelNum = safeParseFloat(travelRaw) || 0;
          const travelEnabled = travelNum > 0;

          const isLeaveRaw = row.isLeave ?? '';
          const isLeave = (isLeaveRaw === 'TRUE' || isLeaveRaw === true);

          const trvCountryRaw = row.travelCountry ?? row['Travel Country'] ?? '';
          return {
            date: rawDate,
            weekday: row.weekday || (rawDate ? getWeekdayChar(rawDate) : ''),
            v167,
            v134,
            v166,
            v267,
            base: (baseRaw || '').toString(),
            travel: (travelRaw || '').toString(),
            otSalary: (otSalaryRaw || '').toString(),
            total: (totalRaw || '').toString(),
            monthSLR: (monthSlrRaw || '').toString(),
            otSum: (otSumRaw || '').toString(),
            remark: (remarkRaw || '').toString(),
            travelCountry: trvCountryRaw || (travelEnabled ? 'Vietnam' : 'None'),
            endTime: (row.endTime && row.endTime.toString().includes('NaN')) ? '' : (row.endTime || ''),
            isLeave: isLeave,
            leaveType: row.leaveType || (isLeave ? 'Áâπ‰ºë' : ''),
            leaveAmount: safeParseFloat(row.leaveAmount || (isLeave ? 1 : 0)),
            travelEnabled,
            isHoliday: String(row.isHoliday || '').toUpperCase() === 'TRUE' || row.isHoliday === true,
            __id: 'rec_' + Math.random().toString(36).substr(2, 9) + '_' + index
          };
        } catch (e) {
          console.error(`[OT] Á¨¨ ${index} Á≠ÜË≥áÊñôËΩâÊèõÂ§±Êïó:`, e, row);
          return null;
        }
      }).filter(r => r !== null);

      // ÊéíÂ∫è: Áî±Êñ∞Âà∞Ëàä (Newest First)
      tableData.sort((a, b) => {
        return parseDateSafe(b.date) - parseDateSafe(a.date);
      });
      updateAll();
    }

    // === End Google Sheet Áõ∏ÈóúÂ∑•ÂÖ∑ ===

    // === Smart Stepper Add Card ‰∫íÂãïÈÇèËºØ ===
    const newAddCardState = {
      date: null, // YYYY-MM-DD
      v167: 0,
      v134: 0,
      v166: 0,
      v267: 0,
      travel: 'Vietnam',
      isHoliday: false,
      isLeave: false,
      leaveType: 'Áâπ‰ºë',
      leaveAmount: 1
    };

    const travelOptions = ['None', 'Vietnam', 'China', 'India'];
    const travelDisplay = { 'None': '-', 'Vietnam': 'VN', 'China': 'CN', 'India': 'IN' };

    // ÂàùÂßãÂåñ Smart Stepper AddÊåâÈàï
    function initAddCardSteppers() {
      const dateBtn = document.getElementById('newDate');
      const travelBtn = document.getElementById('newTravelCountry');
      const hourBtn = document.getElementById('newHour');
      const minBtn = document.getElementById('newMinute');
      const holidayToggleBtn = document.getElementById('newHolidayToggle'); // Assuming this button exists

      // Init Default Time State
      newAddCardState.hour = 17;
      newAddCardState.minute = 30;
      newAddCardState.isHoliday = false; // Add flag
      // Add Holiday Toggle Button Logic to UI if not present? User asked to add "Next to +" button.
      // We will create it dynamically or user must add to HTML.
      // JS will handle logic.

      // Êó•ÊúüÊåâÈàïÔºöÈªûÊìäÈñãÂïüÊó•ÊúüÈÅ∏ÊìáÂô®
      if (dateBtn) {
        dateBtn.addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'date';
          input.value = newAddCardState.date || '';

          // Improved styling to fix transparency and rectangular glitch
          Object.assign(input.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '280px',
            height: '60px',
            fontSize: '20px',
            padding: '10px',
            zIndex: '10000',
            borderRadius: '16px',
            border: '2px solid #007AFF', // var(--color-primary)
            background: '#ffffff', // Force solid background
            boxShadow: '0 8px 32px rgba(0,0,0,0.3)',
            outline: 'none',
            color: '#000000'
          });

          document.body.appendChild(input);

          input.addEventListener('change', () => {
            if (input.value) {
              newAddCardState.date = input.value;
              const d = parseDateSafe(input.value);
              const mm = String(d.getMonth() + 1).padStart(2, '0');
              const dd = String(d.getDate()).padStart(2, '0');
              dateBtn.textContent = `${mm}/${dd}`;
              dateBtn.classList.add('has-value');
            }
            if (document.body.contains(input)) document.body.removeChild(input);
          });
          input.addEventListener('blur', () => {
            // Delay to allow change event if processed on mobile
            setTimeout(() => { if (document.body.contains(input)) document.body.removeChild(input); }, 300);
          });
          setTimeout(() => { input.focus(); input.click(); }, 100);
        });
      }

      const updateTravelUI = () => {
        if (!travelBtn) return;
        const isTraveling = newAddCardState.travel !== 'None';
        const iconColor = isTraveling ? 'var(--color-primary)' : 'rgba(0,0,0,0.5)';
        const bgColor = isTraveling ? 'rgba(0, 122, 255, 0.15)' : 'rgba(0,0,0,0.05)';
        travelBtn.style.background = bgColor;

        let badgeHtml = '';
        if (isTraveling) {
          const shortCode = getCountryAbbr(newAddCardState.travel);
          badgeHtml = `<span style="position:absolute; bottom:2px; right:2px; font-size:8px; font-weight:800; color:var(--color-primary); background:white; padding:1px 2px; border-radius:3px; line-height:1;">${shortCode}</span>`;
        }
        travelBtn.innerHTML = `<span class="material-symbols-outlined" style="font-size: 24px; color: ${iconColor}">flight</span>${badgeHtml}`;
      };

      // Travel ÊåâÈàï logic
      if (travelBtn) {

        let dragState = null;

        travelBtn.addEventListener('mousedown', (e) => {
          const travels = ['None', ...Object.keys(getTravelRates())];
          dragState = { startY: e.clientY, moved: false, travels };
          travelBtn.classList.add('active');
        });

        const onMove = (e) => {
          if (!dragState) return;
          const delta = dragState.startY - e.clientY;
          if (Math.abs(delta) > 10) dragState.moved = true;
          if (Math.abs(delta) > 40) {
            const travels = dragState.travels;
            const curr = travels.indexOf(newAddCardState.travel);
            const next = delta > 0 ? (curr + 1) % travels.length
              : (curr - 1 + travels.length) % travels.length;
            newAddCardState.travel = travels[next];
            updateTravelUI();
            dragState.startY = e.clientY;
          }
        };
        const onUp = () => {
          if (dragState) {
            const travels = dragState.travels;
            if (!dragState.moved) {
              const curr = travels.indexOf(newAddCardState.travel);
              const next = (curr + 1) % travels.length;
              newAddCardState.travel = travels[next];
              updateTravelUI();
            }
            travelBtn.classList.remove('active');
            dragState = null;
          }
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
        };
        travelBtn.addEventListener('mousedown', () => {
          // Note: mousedown is also handled above to init travels list
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
      }

      // Holiday Toggle Button Logic
      if (holidayToggleBtn) {
        holidayToggleBtn.addEventListener('click', () => {
          newAddCardState.isHoliday = !newAddCardState.isHoliday;
          holidayToggleBtn.classList.toggle('on', newAddCardState.isHoliday);
          const icon = holidayToggleBtn.querySelector('.material-symbols-outlined');
          if (icon) {
            icon.textContent = newAddCardState.isHoliday ? 'holiday_village' : 'event_busy';
            icon.style.color = newAddCardState.isHoliday ? 'var(--color-warning)' : 'rgba(0,0,0,0.5)';
          }
        });
      }

      // Leave Toggle for Add Card
      const leaveToggleBtn = document.getElementById('newLeaveToggle');
      const leaveInfoWrapper = document.getElementById('leaveInfoWrapper');
      const leaveInfoRow = document.getElementById('leaveInfoRow');

      // Replace these with capsule selectors dynamically
      if (leaveInfoRow) {
        leaveInfoRow.innerHTML = '';

        const types = [
          'Áâπ‰ºë', '‰∫ãÂÅá', 'ÁóÖÂÅá', 'ÂÖ¨ÂÅá', 'Â©öÂÅá', 'ÂÖ¨ÂÇ∑ÂÅá', 'Âñ™ÂÅá',
          'ÊúâËñ™Áî¢ÂÅá', 'ÁÑ°Ëñ™Áî¢ÂÅá', 'Ë£ú‰ºë', 'Áî¢Ê™¢ÂÅá', 'Èô™Áî¢Ê™¢ÂèäÈô™Áî¢ÂÅá',
          'ÈßêÂú∞‰ºëÂÅá', 'ÁîüÁêÜÂÅá', 'ÂÆ∂Â∫≠ÁÖßÈ°ßÂÅá', '‰ΩèÈô¢ÁóÖÂÅá', 'ÂÅ•Ê™¢ÂÅá'
        ];
        const typeCapsule = renderCapsuleSelector(types, newAddCardState.leaveType || 'Áâπ‰ºë', (val) => {
          newAddCardState.leaveType = val;
        });

        const amts = [
          { value: 1, label: '1.0 Â§©' }, { value: 0.5, label: '0.5 Â§©' }, { value: 0.125, label: '1 Â∞èÊôÇ' }, { value: 0.25, label: '2 Â∞èÊôÇ' }, { value: 0.375, label: '3 Â∞èÊôÇ' }, { value: 0.5, label: '4 Â∞èÊôÇ' }
        ];
        const amtCapsule = renderCapsuleSelector(amts, 1, (val) => {
          newAddCardState.leaveAmount = parseFloat(val);
        });
        const amtToggle = amtCapsule.querySelector('.capsule-toggle');
        if (amtToggle) amtToggle.textContent = '1.0 Â§©';

        leaveInfoRow.appendChild(typeCapsule);
        leaveInfoRow.appendChild(amtCapsule);
      }



      if (leaveToggleBtn) {
        leaveToggleBtn.addEventListener('click', () => {
          newAddCardState.isLeave = !newAddCardState.isLeave;
          leaveToggleBtn.classList.toggle('on', newAddCardState.isLeave);

          const unit = document.getElementById('leaveCapsuleUnit');

          if (leaveInfoWrapper) {
            if (newAddCardState.isLeave) {
              leaveInfoWrapper.classList.add('expanded');
              if (unit) unit.classList.add('expanded');
            } else {
              leaveInfoWrapper.classList.remove('expanded');
              if (unit) unit.classList.remove('expanded');
            }
          }

          const icon = leaveToggleBtn.querySelector('.material-symbols-outlined');
          if (icon) {
            icon.textContent = newAddCardState.isLeave ? 'person_off' : 'person';
            icon.style.color = newAddCardState.isLeave ? '#ba1a1a' : 'rgba(0,0,0,0.5)';
          }
          if (newAddCardState.isLeave) {
            newAddCardState.leaveType = newAddCardState.leaveType || 'Áâπ‰ºë';
            newAddCardState.leaveAmount = newAddCardState.leaveAmount || 1;
          }
        });
      }

      // Hour Button Logic
      if (hourBtn) {
        let hDrag = null;
        const startHDrag = (y) => {
          hDrag = { startY: y, startVal: newAddCardState.hour };
          hourBtn.classList.add('active');
        };
        const moveHDrag = (y) => {
          if (!hDrag) return;
          const delta = Math.floor((hDrag.startY - y) / 10);
          let newVal = (hDrag.startVal + delta) % 24;
          if (newVal < 0) newVal += 24;
          if (newVal !== newAddCardState.hour) {
            newAddCardState.hour = newVal;
            hourBtn.textContent = String(newVal).padStart(2, '0');
          }
        };
        const endHDrag = () => {
          if (hDrag) {
            hourBtn.classList.remove('active');
            hDrag = null;
          }
        };

        const onHMove = (e) => moveHDrag(e.clientY);
        const onHUp = () => {
          endHDrag();
          document.removeEventListener('mousemove', onHMove);
          document.removeEventListener('mouseup', onHUp);
        };
        const onHTouchMove = (e) => moveHDrag(e.touches[0].clientY);
        const onHTouchEnd = () => {
          endHDrag();
          document.removeEventListener('touchmove', onHTouchMove);
          document.removeEventListener('touchend', onHTouchEnd);
        };

        hourBtn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startHDrag(e.clientY);
          document.addEventListener('mousemove', onHMove);
          document.addEventListener('mouseup', onHUp);
        });
        hourBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startHDrag(e.touches[0].clientY);
          document.addEventListener('touchmove', onHTouchMove, { passive: false });
          document.addEventListener('touchend', onHTouchEnd);
        });
      }

      // Minute Button Logic
      if (minBtn) {
        let mDrag = null;
        const startMDrag = (y) => {
          mDrag = { startY: y, startVal: newAddCardState.minute };
          minBtn.classList.add('active');
        };
        const moveMDrag = (y) => {
          if (!mDrag) return;
          const steps = Math.floor((mDrag.startY - y) / 10);
          let newVal = (mDrag.startVal + (steps * 10)) % 60;
          if (newVal < 0) newVal += 60;
          if (newVal !== newAddCardState.minute) {
            newAddCardState.minute = newVal;
            minBtn.textContent = String(newVal).padStart(2, '0');
          }
        };
        const endMDrag = () => {
          if (mDrag) {
            minBtn.classList.remove('active');
            mDrag = null;
          }
        };

        const onMMove = (e) => moveMDrag(e.clientY);
        const onMUp = () => {
          endMDrag();
          document.removeEventListener('mousemove', onMMove);
          document.removeEventListener('mouseup', onMUp);
        };
        const onMTouchMove = (e) => moveMDrag(e.touches[0].clientY);
        const onMTouchEnd = () => {
          endMDrag();
          document.removeEventListener('touchmove', onMTouchMove);
          document.removeEventListener('touchend', onMTouchEnd);
        };

        minBtn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startMDrag(e.clientY);
          document.addEventListener('mousemove', onMMove);
          document.addEventListener('mouseup', onMUp);
        });
        minBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startMDrag(e.touches[0].clientY);
          document.addEventListener('touchmove', onMTouchMove, { passive: false });
          document.addEventListener('touchend', onMTouchEnd);
        });
      }

      // Add Row Button
      const addBtn = document.getElementById('addRowCard');
      if (addBtn) {
        addBtn.addEventListener('click', () => {
          if (!newAddCardState.date) {
            showNotification('Ë´ãÂÖàÈÅ∏ÊìáÊó•Êúü', true);
            // Highlight date button
            if (dateBtn) {
              dateBtn.style.animation = 'shake 0.4s ease';
              setTimeout(() => dateBtn.style.animation = '', 400);
            }
            return;
          }

          const exists = tableData.some((d) => d.date === newAddCardState.date);
          if (exists) {
            showNotification('Ë©≤Êó•ÊúüÂ∑≤Â≠òÂú®', true);
            return;
          }

          // Holiday Check handled in UI (we need to read the state)
          // We need to add the Holiday Button to the DOM first (handled in initAddCardSteppers or manually inserted)
          const isLeave = newAddCardState.isLeave || false;
          const res = isLeave
            ? { v134: 0, v167: 0, v166: 0, v267: 0, total: 0 }
            : calculateOvertime(newAddCardState.hour, newAddCardState.minute, newAddCardState.date, newAddCardState.isHoliday);

          const newEntry = {
            date: newAddCardState.date,
            v167: res.v167,
            v134: res.v134,
            v166: res.v166, // Holiday 2.0 bucket
            v267: res.v267,
            isLeave: isLeave,
            remark: '',
            travelCountry: newAddCardState.travel,
            endTime: `${String(newAddCardState.hour).padStart(2, '0')}:${String(newAddCardState.minute).padStart(2, '0')}`,
            leaveType: isLeave ? newAddCardState.leaveType : '',
            leaveAmount: isLeave ? newAddCardState.leaveAmount : 0
          };

          addNewEntry(newEntry);

          // ÈáçÁΩÆ
          newAddCardState.date = null;
          newAddCardState.hour = 17;
          newAddCardState.minute = 30;
          newAddCardState.travel = 'Vietnam';
          newAddCardState.isHoliday = false; // Reset holiday toggle
          newAddCardState.isLeave = false; // Reset leave toggle

          if (dateBtn) {
            dateBtn.textContent = '--/--';
            dateBtn.classList.remove('has-value');
          }
          if (hourBtn) hourBtn.textContent = '17';
          if (minBtn) minBtn.textContent = '30';

          const leaveToggleBtn = document.getElementById('newLeaveToggle');
          if (leaveToggleBtn) {
            leaveToggleBtn.classList.remove('on');
            const icon = leaveToggleBtn.querySelector('.material-symbols-outlined');
            if (icon) {
              icon.textContent = 'person';
              icon.style.color = 'rgba(0,0,0,0.5)';
            }
          }
          if (leaveInfoWrapper) {
            leaveInfoWrapper.classList.remove('expanded');
          }
          const leaveInfoRow = document.getElementById('leaveInfoRow');
          if (leaveInfoRow) {
            // Reset capsule toggles text
            const toggles = leaveInfoRow.querySelectorAll('.capsule-toggle');
            if (toggles[0]) toggles[0].textContent = 'Áâπ‰ºë';
            if (toggles[1]) toggles[1].textContent = '1.0 Â§©';
          }

          if (holidayToggleBtn) {
            holidayToggleBtn.classList.remove('on');
            const icon = holidayToggleBtn.querySelector('.material-symbols-outlined');
            if (icon) {
              icon.textContent = 'event_busy';
              icon.style.color = 'rgba(0,0,0,0.5)';
            }
          }
          updateTravelUI();

          showNotification('‚úÖ Â∑≤Êñ∞Â¢û‰∏ÄÁ≠ÜË≥áÊñô');
        });
      }
    }

    // Event binding is handled in DOMContentLoaded below for better reliability.


    // Settings Card Toggle Logic (Animation)
    if (global) {
      global.toggleSettingsCard = function () {
        const body = document.getElementById('settingsBody');
        const icon = document.getElementById('settingsExpandIcon');
        // Toggle class 'open' on the wrapper
        body.classList.toggle('open');

        const isOpen = body.classList.contains('open');
        icon.style.transform = isOpen ? 'rotate(180deg)' : 'rotate(0deg)';
      };
    }

    const fillBtn = document.getElementById('fillMissingDatesBtn');
    if (fillBtn) {
      fillBtn.addEventListener('click', () => {
        fillMissingDatesToToday();
      });
    } else {
      console.log(
        '[OT] fillMissingDatesBtn Â∞öÊú™Âä†ÂÖ• HTMLÔºåÂæÖ‰πãÂæåÂä†‰∏äÂç≥ÂèØ‰ΩøÁî®„ÄÇ'
      );
    }

    // ÂàùÂßãËºâÂÖ•ÔºöÂú® Apps Script Web App ‰∏≠ÊúÉÂæû Sheet ËÆÄÂèñË≥áÊñôÔºåÂÖ∂‰ªñÊÉÖÊ≥ÅÈ°ØÁ§∫Á©∫ÁôΩÂÅáË°®
    loadFromSheet();

    // È†êÁïôÁµ¶ LOGO ÈªûÊìäÂëºÂè´ÁöÑÂáΩÂºèÔºöÈ°ØÁ§∫Áï∂ÊúàÁµ±Ë®àÈÄöÁü•
    if (global) {
      global.showOtMonthlySummary = function () {
        const summary = getMonthlySummaryText();
        showNotification('‚úÖ ' + summary);
      };

      // Êö¥Èú≤Âà∞ÂÖ®Âüü‰æõ Analytics ‰ΩøÁî®
      global.updateAll = updateAll;
      global.showNotification = showNotification;
    }
    // ========== Analytics ÂçáÁ¥öÂäüËÉΩ (Â∑≤Âêà‰ΩµËá≥Âêå‰∏Ä Scope) ==========
    // Áî±Êñº analytics.js ÈúÄË¶ÅÂ≠òÂèñ tableData Á≠âÂÖ®ÂüüËÆäÊï∏ÔºåÁõ¥Êé•Âú®Ê≠§ÂÖßÂµå

    // ========== ÂàÜÈ†ÅÂàáÊèõ ==========
    function initTabNavigation() {
      // Logic handled via toggle button
    }

    // ========== Êúà‰ªΩÈÅéÊøæ ==========
    function populateMonthFilter() {
      const filter = document.getElementById('monthFilter');
      if (!filter) return;

      // Êî∂ÈõÜÊâÄÊúâÊúà‰ªΩ
      const months = new Set();
      tableData.forEach(e => {
        if (e.date) months.add(e.date.slice(0, 7));
      });

      // ÊéíÂ∫èÔºàÊñ∞Âà∞ËàäÔºâ
      const sortedMonths = Array.from(months).sort().reverse();
      availableMonths = sortedMonths;

      // Ê∏ÖÁ©∫‰∏¶ÈáçÂª∫
      filter.innerHTML = '<option value="">ÂÖ®ÈÉ®Êúà‰ªΩ</option>';
      sortedMonths.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        filter.appendChild(opt);
      });

      // Á∂ÅÂÆö‰∫ã‰ª∂
      filter.addEventListener('change', (e) => {
        selectedMonth = e.target.value || null;
        updateAll();
        updateCharts();
        updateAnalyticsStats();
      });
    }

    // ========== Chart.js ÂúñË°® ==========
    // --- Global Esc Key Listener ---
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (typeof closeSalaryModal === 'function') closeSalaryModal();
        if (typeof closeTravelRateModal === 'function') closeTravelRateModal();
        if (typeof closeRulesModal === 'function') closeRulesModal();
        if (typeof closeLeaveManagementModal === 'function') closeLeaveManagementModal();
      }
    });

    // === Charts Helper: Center Text Plugin ===
    const centerTextPlugin = {
      id: 'centerText',
      afterDraw(chart) {
        if (chart.canvas.id !== 'incomeChart') return;
        const { ctx, width, height } = chart;
        ctx.restore();

        const sum = chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
        const isNeumo = document.documentElement.getAttribute('data-theme') === 'neumorphic';

        const fontSize = (height / 160).toFixed(2);
        ctx.font = `600 ${fontSize}em "Open Sans", sans-serif`;
        ctx.textBaseline = 'middle';
        ctx.fillStyle = isNeumo ? '#444' : '#1d1d1f';

        const text = Math.round(sum).toLocaleString();
        const textX = Math.round((width - ctx.measureText(text).width) / 2);
        const textY = height / 2 - 5;

        ctx.fillText(text, textX, textY);

        ctx.font = `400 ${(fontSize * 0.4)}em sans-serif`;
        ctx.fillStyle = isNeumo ? '#888' : '#666';
        const subText = 'Total Income';
        const subX = Math.round((width - ctx.measureText(subText).width) / 2);
        const subY = height / 2 + 15;
        ctx.fillText(subText, subX, subY);

        ctx.save();
      }
    };

    function initCharts(force = false) {
      if (chartsInitialized && !force) return;
      if (typeof Chart === 'undefined') return;

      if (force) {
        Object.values(charts).forEach(c => {
          if (c && typeof c.destroy === 'function') c.destroy();
        });
        charts = {};
      }

      const ctxOvertime = document.getElementById('overtimeChart')?.getContext('2d');
      const ctxIncome = document.getElementById('incomeChart')?.getContext('2d');
      const ctxAttendance = document.getElementById('attendanceChart')?.getContext('2d');
      const ctxSalaryTrend = document.getElementById('salaryTrendChart')?.getContext('2d');

      if (!ctxOvertime || !ctxIncome || !ctxAttendance || !ctxSalaryTrend) return;

      const isNeumo = document.documentElement.getAttribute('data-theme') === 'neumorphic';
      const textColor = isNeumo ? '#666' : '#333';

      try {
        if (typeof ChartDataLabels !== 'undefined' && !Chart.registry.plugins.get('datalabels')) {
          Chart.register(ChartDataLabels);
        }
        if (!Chart.registry.plugins.get('centerText')) {
          Chart.register(centerTextPlugin);
        }
      } catch (e) { console.warn('[OT] Plugin registration error:', e); }

      // 1. Overtime Trend
      charts.overtime = new Chart(ctxOvertime, {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'OT Hours', data: [], borderColor: '#007AFF', tension: 0.4, fill: true, backgroundColor: 'rgba(0,122,255,0.1)' }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, datalabels: { display: false } },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { color: textColor, callback: (val) => val.toFixed(1) }
            },
            x: { ticks: { color: textColor } }
          }
        }
      });

      // 2. Income Structure
      charts.income = new Chart(ctxIncome, {
        type: 'doughnut',
        data: {
          labels: ['Salary', 'Travel', 'OT'],
          datasets: [{
            data: [0, 0, 0],
            backgroundColor: ['#4CD964', '#FF9500', '#007AFF'],
            borderWidth: 0,
            hoverOffset: 10
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '75%',
          plugins: {
            legend: { position: 'bottom', labels: { boxWidth: 12, color: textColor } },
            datalabels: {
              color: '#fff',
              formatter: (value, ctx) => {
                const sum = ctx.dataset.data.reduce((a, b) => a + b, 0);
                if (sum === 0) return '';
                return (value * 100 / sum).toFixed(1) + '%';
              },
              font: { weight: 'bold', size: 10 }
            },
            tooltip: {
              callbacks: {
                label: (item) => `${item.label}: ${Math.round(item.raw).toLocaleString()}`
              }
            },
            centerText: {
              display: true,
              text: 'Total',
              label: 'Income'
            }
          }
        }
      });

      // 3. Attendance Chart (Straight lines)
      charts.attendance = new Chart(ctxAttendance, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'Office Days', data: [], borderColor: isNeumo ? '#7d8288' : '#007AFF', backgroundColor: 'rgba(0,122,255,0.05)', tension: 0, fill: true },
            { label: 'Travel Days', data: [], borderColor: isNeumo ? '#9da6b0' : '#FF9500', backgroundColor: 'rgba(255,149,0,0.05)', tension: 0, fill: true }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom', labels: { color: textColor } },
            datalabels: { display: false }
          },
          scales: { y: { beginAtZero: true, ticks: { color: textColor } }, x: { ticks: { color: textColor } } }
        }
      });

      // 4. Salary Trend (Stacked Area)
      charts.salaryTrend = new Chart(ctxSalaryTrend, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'Base', data: [], borderColor: '#666', borderDash: [5, 5], tension: 0, fill: true, backgroundColor: isNeumo ? 'rgba(150,150,150,0.1)' : 'rgba(102,102,102,0.1)' },
            { label: 'OT Pay', data: [], borderColor: isNeumo ? '#5d6268' : '#34C759', tension: 0, fill: true, backgroundColor: isNeumo ? 'rgba(100,100,100,0.2)' : 'rgba(52,199,89,0.1)' },
            { label: 'Travel', data: [], borderColor: isNeumo ? '#8d9296' : '#FF9500', tension: 0, fill: true, backgroundColor: isNeumo ? 'rgba(120,120,120,0.3)' : 'rgba(255,149,0,0.1)' }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'bottom', labels: { color: textColor } },
            datalabels: { display: false }
          },
          scales: {
            y: {
              stacked: true,
              beginAtZero: true,
              ticks: { color: textColor }
            },
            x: { ticks: { color: textColor } }
          }
        }
      });

      chartsInitialized = true;
    }

    function updateCharts() {
      if (!chartsInitialized) initCharts();
      if (!charts.overtime) return;

      try {
        let totalBase = 0, totalTravel = 0, totalOtPay = 0;
        tableData.forEach(entry => {
          if (!entry.date) return;
          const mKey = entry.date.slice(0, 7).replace(/\//g, '-');
          if (selectedMonth && mKey !== selectedMonth) return;
          totalBase += safeParseFloat(entry.base || 0);
          totalTravel += safeParseFloat(entry.travel || 0);
          totalOtPay += safeParseFloat(entry.otSalary || 0);
        });

        const allMonthsData = {};
        const allMonthsAttendance = {};
        const allMonthsSalaryComponents = {};

        tableData.forEach(e => {
          if (!e.date || e.date.length < 7) return;
          const k = e.date.slice(0, 7).replace(/\//g, '-');
          if (allMonthsData[k] === undefined) {
            allMonthsData[k] = 0;
            allMonthsAttendance[k] = { work: 0, travel: 0 };
            allMonthsSalaryComponents[k] = { base: 0, ot: 0, travel: 0 };
          }
          allMonthsData[k] += !!e.isLeave ? 0 : safeParseFloat(e.otSum || 0);
          const isTravel = (e.travelCountry && e.travelCountry !== 'None') || (safeParseFloat(e.travel || 0) > 0);
          const date = parseDateSafe(e.date);
          const isWeekend = (date.getDay() === 0 || date.getDay() === 6);
          const isOffice = (!e.isLeave && !isWeekend) || (safeParseFloat(e.otSum || 0) > 0);
          if (isTravel) allMonthsAttendance[k].travel++;
          if (isOffice) allMonthsAttendance[k].work++;
          allMonthsSalaryComponents[k].ot += safeParseFloat(e.otSalary || 0);
          allMonthsSalaryComponents[k].travel += safeParseFloat(e.travel || 0);
        });

        let salaryHistory = globalSettings.salaryHistory || [];
        Object.keys(allMonthsSalaryComponents).forEach(k => {
          const applicable = salaryHistory.find(h => h.date <= k) || salaryHistory[salaryHistory.length - 1];
          allMonthsSalaryComponents[k].base = applicable ? safeParseFloat(applicable.amount) : 68000;
        });

        const sortedMonths = Object.keys(allMonthsData).sort();

        // Update Overtime Chart
        charts.overtime.data.labels = sortedMonths;
        charts.overtime.data.datasets[0].data = sortedMonths.map(m => allMonthsData[m]);
        charts.overtime.update();

        // Update Income Chart
        charts.income.data.datasets[0].data = [totalBase, totalTravel, totalOtPay];
        charts.income.update();

        // Update Attendance Chart
        charts.attendance.data.labels = sortedMonths;
        charts.attendance.data.datasets[0].data = sortedMonths.map(m => allMonthsAttendance[m].work);
        charts.attendance.data.datasets[1].data = sortedMonths.map(m => allMonthsAttendance[m].travel);
        charts.attendance.update();

        // Update Salary Trend
        charts.salaryTrend.data.labels = sortedMonths;
        charts.salaryTrend.data.datasets[0].data = sortedMonths.map(m => allMonthsSalaryComponents[m].base);
        charts.salaryTrend.data.datasets[1].data = sortedMonths.map(m => Math.round(allMonthsSalaryComponents[m].ot));
        charts.salaryTrend.data.datasets[2].data = sortedMonths.map(m => Math.round(allMonthsSalaryComponents[m].travel));
        charts.salaryTrend.update();
      } catch (err) { console.error('[OT] updateCharts failed:', err); }
    }

    // Êõ¥Êñ∞Áµ±Ë®àÂç°Áâá
    function updateAnalyticsStats() {
      let workDays = 0;
      let totalOT = 0;
      let travelDays = 0;
      let totalIncome = 0;
      let totalOTSalary = 0;
      let totalTravelAllowance = 0;

      let weekdayDays = 0;
      let weekendDays = 0;
      let thisMonthIncome = 0;

      const today = new Date();
      const currentMonthKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;

      // Ê†πÊìöÁØ©ÈÅ∏Âô®Ê±∫ÂÆöË®àÁÆóÁØÑÂúç
      const targetData = selectedMonth
        ? tableData.filter(e => e.date && e.date.replace(/\//g, '-').startsWith(selectedMonth))
        : tableData;

      targetData.forEach(entry => {
        if (!entry.date) return;

        const isLeave = !!entry.isLeave;
        const leaveType = entry.leaveType || '';

        // [Audit Fix] Êé°Áî®ËàáÂúñË°®‰∏ÄËá¥ÁöÑÂåÖÂÆπÊÄßÈÇèËºØ
        const isTrv = (entry.travelCountry && entry.travelCountry !== 'None') || (parseFloat(entry.travel || 0) > 0);
        // Force local time parsing
        const date = parseDateSafe(entry.date);
        const dayNum = date.getDay();
        const isWknd = (dayNum === 0 || dayNum === 6);
        const otVal = parseFloat(entry.otSum || 0);
        const isOff = (!isLeave && !isWknd) || (otVal > 0);

        if (isOff) {
          workDays++;
          totalOT += otVal;
        }
        if (isTrv) {
          travelDays++;
        }
        totalTravelAllowance += parseFloat(entry.travel || 0);

        const otSal = parseFloat(entry.otSalary || 0);
        totalOTSalary += otSal;

        const income = parseFloat(entry.total || 0);
        totalIncome += income;

        // Âà§Êñ∑Âπ≥Êó•/ÈÄ±Êú´ (Áµ±Ë®àÂä†Áè≠Ê¨°Êï∏ËàáÂ§©Êï∏)
        if (dayNum === 0 || dayNum === 6) {
          if (otVal > 0) weekendDays++;
        } else {
          if (otVal > 0) weekdayDays++;
        }

        // Â¶ÇÊûúÊú™ÈÅ∏Êúà‰ªΩÔºåÂâáÁµ±Ë®à„ÄåÁï∂ÂâçÈÄôÂÄãÊúà„ÄçÁöÑÊî∂ÂÖ•‰ΩúÁÇ∫Êú¨ÊúàÊî∂ÂÖ•
        if (!selectedMonth) {
          if (entry.date.startsWith(currentMonthKey)) {
            thisMonthIncome += income;
          }
        }
      });

      // Â¶ÇÊûúÊúâÈÅ∏Êúà‰ªΩÔºå„ÄåÊú¨ÊúàÊî∂ÂÖ•„ÄçÂ∞±È°ØÁ§∫Ë©≤ÊúàÊî∂ÂÖ•
      if (selectedMonth) {
        thisMonthIncome = totalIncome;
      }

      // --- Â∞àÊ•≠ÊåáÊ®ôË®àÁÆó ---

      // 1. Âπ≥ÂùáË®àÁÆó
      const avgDaily = workDays > 0 ? totalIncome / workDays : 0;
      const uniqueMonths = new Set(targetData.map(e => e.date.slice(0, 7))).size;
      const avgMonthly = uniqueMonths > 0 ? totalIncome / uniqueMonths : totalIncome;

      // 2. ÂØ¶Ë≥™ÊôÇËñ™ (ÊúâÊïà)ÔºöÁ∏ΩÊî∂ÂÖ• / (Ê®ôÊ∫ñÂ∑•ÊôÇ + Âä†Áè≠Â∑•ÊôÇ)
      const standardWorkHours = workDays * 8;
      const totalWorkHours = standardWorkHours + totalOT;
      const effectiveHourly = totalWorkHours > 0 ? totalIncome / totalWorkHours : 0;

      // 3. Âá∫Â∑ÆË£úË≤º‰ΩîÊØîÔºöÂá∫Â∑ÆÂä†Áµ¶ / Á∏ΩÊî∂ÂÖ•
      const travelRatio = totalIncome > 0 ? (totalTravelAllowance / totalIncome) * 100 : 0;

      // 4. Âä†Áè≠Ë≤¢ÁçªÂ∫¶ÔºöÂä†Áè≠Ë≤ª / Á∏ΩÊî∂ÂÖ•
      const otImpact = totalIncome > 0 ? (totalOTSalary / totalIncome) * 100 : 0;

      // --- DOM Êõ¥Êñ∞ ---
      const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
      };

      // Áµ±Ë®àÊó•ÊúüÁØÑÂúç (yy/mm/dd-yy/mm/dd)
      if (targetData.length > 0) {
        // ÂÖàÊåâÊó•ÊúüÊéíÂ∫è
        const sorted = [...targetData].sort((a, b) => parseDateSafe(a.date) - parseDateSafe(b.date));
        const first = parseDateSafe(sorted[0].date);
        const last = parseDateSafe(sorted[sorted.length - 1].date);

        const fmtDate = (d) => {
          const yy = String(d.getFullYear()).slice(-2);
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          return `${yy}/${mm}/${dd}`;
        };
        setEl('statDateRange', `${fmtDate(first)}-${fmtDate(last)}`);
      } else {
        setEl('statDateRange', '--/--/-- - --/--/--');
      }

      const fmt = (n) => Math.round(n).toLocaleString();
      const pct = (n) => n.toFixed(1) + '%';

      setEl('statWorkDays', workDays);
      setEl('statTravelDays', travelDays);
      setEl('statWeekdayDays', weekdayDays);
      setEl('statWeekendDays', weekendDays);

      setEl('statAvgDaily', fmt(avgDaily));
      setEl('statAvgHourly', fmt(effectiveHourly)); // Ëàä ID ‰øùÁïô‰ΩÜÂÖßÂÆπÊîπÁÇ∫ÊúâÊïàÊôÇËñ™ÔºåÊàñËÄÖÊñ∞Â¢û ID
      setEl('statEffectiveHourly', fmt(effectiveHourly));
      setEl('statAvgMonthly', fmt(avgMonthly));

      setEl('statTotalIncome', fmt(totalIncome));
      setEl('statThisMonthIncome', fmt(thisMonthIncome));
      setEl('statOTHours', totalOT.toFixed(1));

      setEl('statTravelRatio', pct(travelRatio));
      setEl('statOTImpact', pct(otImpact));
    }

    // Overview È†ÅÈù¢ÁöÑÂåØÁéáÊõ¥Êñ∞ÊåâÈàï
    const refreshOverviewBtn = document.getElementById('refreshRateOverviewBtn');
    if (refreshOverviewBtn) {
      refreshOverviewBtn.addEventListener('click', async () => {
        refreshOverviewBtn.disabled = true;
        const icon = refreshOverviewBtn.querySelector('.material-symbols-outlined');
        if (icon) icon.style.animation = 'spin 1s linear infinite';

        try {
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run
              .withSuccessHandler((rate) => {
                document.getElementById('usdRate').value = rate.toFixed(2);
                updateAll();
                showNotification(`‚úÖ ÂåØÁéáÂ∑≤Êõ¥Êñ∞: 1 USD = ${rate.toFixed(2)} TWD`);
                refreshOverviewBtn.disabled = false;
                if (icon) icon.style.animation = '';
              })
              .withFailureHandler(() => {
                showNotification('‚ùå ÂåØÁéáÊõ¥Êñ∞Â§±ÊïóÔºåË´ãÊ™¢Êü•Á∂≤Ë∑ØÈÄ£Á∑ö', true);
                refreshOverviewBtn.disabled = false;
                if (icon) icon.style.animation = '';
              })
              .getExchangeRate('USD', 'TWD', true);
          } else {
            showNotification('‚ö†Ô∏è ÂÉÖÂú® Apps Script Áí∞Â¢É‰∏≠ÂèØÁî®', true);
            refreshOverviewBtn.disabled = false;
            if (icon) icon.style.animation = '';
          }
        } catch (err) {
          refreshOverviewBtn.disabled = false;
          if (icon) icon.style.animation = '';
        }
      });
    }

    // Ripple ÊïàÊûúÂáΩÊï∏
    function createRipple(event, button) {
      const ripple = document.createElement('span');
      ripple.classList.add('ripple');

      const rect = button.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      const x = event.clientX - rect.left - size / 2;
      const y = event.clientY - rect.top - size / 2;

      ripple.style.width = ripple.style.height = size + 'px';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';

      button.appendChild(ripple);

      setTimeout(() => ripple.remove(), 600);
    }

    // Êö¥Èú≤Áµ¶ÂÖ®Âüü
    window.updateCharts = updateCharts;
    window.updateAnalyticsStats = updateAnalyticsStats;
    window.populateMonthFilter = populateMonthFilter;
    window.initCharts = initCharts;

    // To make sure updateMonthStatsDOM is available globally for updateAll to call:
    window.updateMonthStatsDOM = function () {
      const monthHeaders = document.querySelectorAll('.month-header');
      if (!monthHeaders.length) return;

      // Calculate sums per month using the same logic as renderDataList
      const monthSums = {};
      tableData.forEach(d => {
        if (!d.date) return;
        const m = d.date.slice(0, 7);
        if (!monthSums[m]) monthSums[m] = { ot: 0, trv: 0, slr: 0 };

        monthSums[m].ot += (parseFloat(d.otSalary) || 0);
        monthSums[m].trv += (parseFloat(d.travel) || 0);
        if (d.monthSLR) monthSums[m].slr = parseFloat(d.monthSLR);
      });

      monthHeaders.forEach(header => {
        const mKey = header.dataset.monthKey;
        if (mKey && monthSums[mKey]) {
          const sums = monthSums[mKey];

          // Update Travel Chip (Blue)
          const trvChip = header.querySelector('.travel-chip span:nth-child(2)');
          if (trvChip) trvChip.textContent = Math.round(sums.trv).toLocaleString();

          // Update Yellow Chip (OT)
          const otChip = header.querySelector('.ot-chip span:nth-child(2)');
          if (otChip) otChip.textContent = '+' + Math.round(sums.ot).toLocaleString();

          // Update Salary Chip (Month SLR)
          const salChip = header.querySelector('.salary-chip');
          if (salChip) {
            const spans = salChip.querySelectorAll('span');
            if (spans.length >= 2) spans[1].textContent = Math.round(sums.slr).toLocaleString();
          }
        }
      });
    };

    // --- Salary History Modal Logic ---
    let currentSalaryIndex = -1; // -1 for new, else index in history

    window.openSalaryModal = function () {
      const modal = document.getElementById('salaryModal');
      modal.classList.add('active');
      renderSalaryList();
    };

    window.openTravelRateModal = function () {
      const modal = document.getElementById('travelRateModal');
      modal.classList.add('active');
      renderTravelRateList();
      initDefaultChinaRate();
    };

    window.openLeaveManagementModal = function () {
      const modal = document.getElementById('leaveManagementModal');
      modal.classList.add('active');
      updateLeaveSummaryDOM();
    };

    window.closeSalaryModal = function () {
      document.getElementById('salaryModal').classList.remove('active');
    };
    window.closeTravelRateModal = function () {
      document.getElementById('travelRateModal').classList.remove('active');
    };
    window.closeLeaveManagementModal = function () {
      document.getElementById('leaveManagementModal').classList.remove('active');
    };

    function getSalaryHistory() {
      if (!globalSettings.salaryHistory || globalSettings.salaryHistory.length === 0) {
        globalSettings.salaryHistory = [{ date: '2024-01', amount: 68000 }];
      }
      return globalSettings.salaryHistory.sort((a, b) => b.date.localeCompare(a.date));
    }

    function saveSalaryHistory(history) {
      globalSettings.salaryHistory = history;
      storage.set('globalSettings', JSON.stringify(globalSettings));
    }

    let salaryEditState = {}; // index -> { date, amount }

    function renderSalaryList() {
      const list = document.getElementById('salaryList');
      const history = getSalaryHistory();
      list.innerHTML = '';

      history.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'salary-item';
        div.dataset.index = index;

        const isEditing = !!salaryEditState[index];
        const displayItem = isEditing ? salaryEditState[index] : item;
        const [year, month] = displayItem.date.split('-');

        div.innerHTML = `
          <div class="salary-date-steppers" style="display:flex; gap:4px;">
            <div class="stepper-btn salary-year-stepper" data-index="${index}" data-type="year">${year}</div>
            <div class="stepper-btn salary-month-stepper" data-index="${index}" data-type="month">${month}</div>
          </div>
          <input type="number" value="${displayItem.amount}" oninput="onSalaryAmountInput(${index}, this.value)" style="width:100px;">
          <div class="salary-actions">
            <span class="material-symbols-outlined btn-v" onclick="confirmSalaryEdit(${index})" style="${isEditing ? '' : 'display:none'}">check_circle</span>
            <span class="material-symbols-outlined btn-x" onclick="cancelSalaryEdit(${index})" style="${isEditing ? '' : 'display:none'}">cancel</span>
            <span class="material-symbols-outlined btn-del" onclick="deleteSalaryItem(${index})" style="${isEditing ? 'display:none' : ''}">delete</span>
          </div>
        `;
        list.appendChild(div);
      });
      initSalaryStepperEvents();
    }

    window.onSalaryAmountInput = function (index, val) {
      const history = getSalaryHistory();
      const amount = parseFloat(val) || 0;

      const itemDiv = document.querySelector(`.salary-item[data-index="${index}"]`);
      if (!salaryEditState[index]) {
        salaryEditState[index] = { ...history[index] };
        // Show confirm/cancel buttons on first change
        if (itemDiv) {
          itemDiv.querySelector('.btn-v').style.display = '';
          itemDiv.querySelector('.btn-x').style.display = '';
          itemDiv.querySelector('.btn-del').style.display = 'none';
        }
      }
      salaryEditState[index].amount = amount;
    };

    window.confirmSalaryEdit = function (index) {
      if (!salaryEditState[index]) return;
      const history = getSalaryHistory();
      history[index] = { ...salaryEditState[index] };
      delete salaryEditState[index];
      storage.set('salaryHistory', JSON.stringify(history));
      updateAll();
      renderSalaryList();
      showNotification('‚úÖ Ëñ™Ë≥áÁ¥ÄÈåÑÂ∑≤Êõ¥Êñ∞');
    };

    window.cancelSalaryEdit = function (index) {
      delete salaryEditState[index];
      renderSalaryList();
    };

    // --- Travel Rate Logic ---
    let travelEditState = {}; // country -> { rate }

    function renderTravelRateList() {
      const list = document.getElementById('travelRateList');
      if (!list) return;
      const rates = getTravelRates();
      list.innerHTML = '';

      Object.keys(rates).forEach(country => {
        const div = document.createElement('div');
        div.className = 'salary-item';
        div.dataset.country = country;

        const isEditing = !!travelEditState[country];
        const displayRate = isEditing ? travelEditState[country].rate : rates[country];

        div.innerHTML = `
          <div style="font-weight:600; font-size:0.9rem; padding: 0 8px;">${country}</div>
          <input type="number" value="${displayRate}" oninput="onTravelRateInput('${country}', this.value)" style="width:100px;">
          <div class="salary-actions">
            <span class="material-symbols-outlined btn-v" onclick="confirmTravelRateEdit('${country}')" style="${isEditing ? '' : 'display:none'}">check_circle</span>
            <span class="material-symbols-outlined btn-x" onclick="cancelTravelRateEdit('${country}')" style="${isEditing ? '' : 'display:none'}">cancel</span>
            <span class="material-symbols-outlined btn-del" onclick="deleteTravelRate('${country}')" style="${isEditing ? 'display:none' : ''}">delete</span>
          </div>
        `;
        list.appendChild(div);
      });
    }

    window.onTravelRateInput = function (country, val) {
      const rates = getTravelRates();
      const rate = parseFloat(val) || 0;

      const itemDiv = document.querySelector(`.salary-item[data-country="${country}"]`);
      if (!travelEditState[country]) {
        travelEditState[country] = { rate: rates[country] };
        if (itemDiv) {
          itemDiv.querySelector('.btn-v').style.display = '';
          itemDiv.querySelector('.btn-x').style.display = '';
          itemDiv.querySelector('.btn-del').style.display = 'none';
        }
      }
      travelEditState[country].rate = rate;
    };

    window.confirmTravelRateEdit = function (country) {
      if (!travelEditState[country]) return;
      const rates = getTravelRates();
      rates[country] = travelEditState[country].rate;
      delete travelEditState[country];
      globalSettings.travelRates = rates;
      storage.set('globalSettings', JSON.stringify(globalSettings));
      renderTravelRateList();
      showNotification(`‚úÖ ${country} Ë≤ªÁéáÂ∑≤Êõ¥Êñ∞`);
    };

    window.cancelTravelRateEdit = function (country) {
      delete travelEditState[country];
      renderTravelRateList();
    };

    window.deleteTravelRate = function (country) {
      if (!confirm(`Á¢∫ÂÆöË¶ÅÂà™Èô§ ${country} ÁöÑË≤ªÁéáÂóéÔºü`)) return;
      const rates = getTravelRates();
      delete rates[country];
      globalSettings.travelRates = rates;
      storage.set('globalSettings', JSON.stringify(globalSettings));
      renderTravelRateList();
    };

    // --- Leave Management Logic ---
    window.saveLeaveQuota = function (val) {
      storage.set('annualLeaveQuota', val);
      updateAll();
    };

    function getLeaveQuota() {
      return parseFloat(storage.get('annualLeaveQuota')) || 5.25;
    }

    function updateLeaveSummaryDOM() {
      const quota = getLeaveQuota();
      let used = 0;
      tableData.forEach(entry => {
        if (entry.isLeave && entry.leaveType === 'Áâπ‰ºë') {
          used += (parseFloat(entry.leaveAmount) || 0);
        }
      });
      const remaining = quota - used;
      const el = document.getElementById('leaveSummaryUI');
      if (el) {
        el.innerHTML = `
          <div style="font-weight: 700; color: var(--color-primary); font-size: 1rem; margin-bottom: 4px;">
            ÂÖ± ${quota} Â§© / Ââ© ${remaining} Â§©
          </div>
          <div style="color: #666; font-size: 0.85rem;">
            Âπ¥Â∫¶Áâπ‰ºë: ${quota} Â§©<br>
            Â∑≤Ë´ãÂ§©Êï∏: ${used} Â§©<br>
            <span style="opacity: 0.7;">(Áî±Á≥ªÁµ±Ëá™ÂãïÂä†Á∏ΩÁâπ‰ºëË®òÈåÑ)</span>
          </div>
        `;
      }
      const input = document.getElementById('annualLeaveQuoata');
      if (input && document.activeElement !== input) {
        input.value = quota;
      }
    }

    window.addTravelRateRecord = function () {
      const country = prompt('Ë´ãËº∏ÂÖ•Âá∫Â∑ÆÂú∞ÂçÄÂêçÁ®±Ôºà‰æãÂ¶ÇÔºöUSAÔºâ:');
      if (!country) return;
      const rates = getTravelRates();
      if (rates[country]) {
        alert('Ë©≤Âú∞ÂçÄÂ∑≤Â≠òÂú®');
        return;
      }
      rates[country] = 40;
      globalSettings.travelRates = rates;
      storage.set('globalSettings', JSON.stringify(globalSettings));
      renderTravelRateList();
    };

    let ratesInProgress = false;
    function initDefaultChinaRate() {
      if (ratesInProgress) return;
      const rates = getTravelRates();
      // Only auto-update if it's the old default values
      if (rates['China'] === 160.25 || rates['China'] === 32.05) {
        ratesInProgress = true;
        google.script.run.withSuccessHandler(rate => {
          ratesInProgress = false;
          if (rate) {
            const chinaUsd = Math.round(250 * rate * 100) / 100; // 250 HKD
            const currentRates = getTravelRates();
            currentRates['China'] = chinaUsd;
            saveTravelRates(currentRates);
            renderTravelRateList();
            console.log(`[OT] China rate updated to ${chinaUsd} USD (250 HKD)`);
          }
        }).withFailureHandler(() => {
          ratesInProgress = false;
        }).getExchangeRate('HKD', 'USD');
      }
    }

    function initSalaryStepperEvents() {
      const modal = document.getElementById('salaryModal');

      const onMove = (e) => {
        if (!dragState || dragState.type !== 'salary') return;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        const deltaY = dragState.lastY - clientY;
        dragState.lastY = clientY;
        dragState.accumulatedDelta += deltaY;

        const threshold = 40;
        if (Math.abs(dragState.accumulatedDelta) >= threshold) {
          const direction = dragState.accumulatedDelta > 0 ? 1 : -1;
          const history = getSalaryHistory();

          if (!salaryEditState[dragState.index]) {
            salaryEditState[dragState.index] = { ...history[dragState.index] };
          }

          let [year, month] = salaryEditState[dragState.index].date.split('-').map(Number);

          if (dragState.subType === 'year') {
            year += direction;
          } else {
            month += direction;
            if (month > 12) { month = 1; year++; }
            if (month < 1) { month = 12; year--; }
          }

          salaryEditState[dragState.index].date = `${year}-${String(month).padStart(2, '0')}`;
          renderSalaryList();

          dragState.accumulatedDelta = 0;
        }
      };

      const mouseUp = () => {
        if (dragState && dragState.type === 'salary') {
          dragState.el.classList.remove('active');
          document.body.classList.remove('is-dragging');
          dragState = null;
        }
      };

      modal.addEventListener('mousedown', (e) => {
        const stepper = e.target.closest('.stepper-btn');
        if (!stepper || (!stepper.classList.contains('salary-year-stepper') && !stepper.classList.contains('salary-month-stepper'))) return;

        document.body.classList.add('is-dragging');

        dragState = {
          type: 'salary',
          subType: stepper.dataset.type,
          index: parseInt(stepper.dataset.index),
          el: stepper,
          lastY: e.clientY,
          accumulatedDelta: 0
        };
        stepper.classList.add('active');
      });

      modal.addEventListener('touchstart', (e) => {
        const stepper = e.target.closest('.stepper-btn');
        if (!stepper || (!stepper.classList.contains('salary-year-stepper') && !stepper.classList.contains('salary-month-stepper'))) return;

        e.preventDefault();
        document.body.classList.add('is-dragging');

        dragState = {
          type: 'salary',
          subType: stepper.dataset.type,
          index: parseInt(stepper.dataset.index),
          el: stepper,
          lastY: e.touches[0].clientY,
          accumulatedDelta: 0
        };
        stepper.classList.add('active');
      }, { passive: false });

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', mouseUp);
      window.addEventListener('touchmove', onMove, { passive: false });
      window.addEventListener('touchend', mouseUp);
    }

    window.updateSalaryItem = function (index, key, value) {
      const history = getSalaryHistory();
      history[index][key] = key === 'amount' ? parseFloat(value) : value;
      storage.set('salaryHistory', JSON.stringify(history));
      updateAll();
    };

    window.addSalaryRecord = function () {
      const history = getSalaryHistory();
      const last = history[0] || { date: '2024-01', amount: 68000 };
      history.unshift({ date: last.date, amount: last.amount });
      saveSalaryHistory(history);
      renderSalaryList();
      updateAll();
    };

    window.deleteSalaryItem = function (index) {
      const history = getSalaryHistory();
      if (history.length <= 1) {
        showNotification('‚ö†Ô∏è Ëá≥Â∞ëÈúÄË¶Å‰∏ÄÁ≠ÜËñ™Ë≥áÁ¥ÄÈåÑ', true);
        return;
      }
      history.splice(index, 1);
      saveSalaryHistory(history);
      renderSalaryList();
      updateAll();
    };

    // ========== Smart Stepper ÊãñÊõ≥‰∫íÂãï ==========
    let dragState = null;

    function initSmartStepperEvents() {
      const container = document.getElementById('tableContainer');
      if (!container) return;

      container.addEventListener('mousedown', (e) => {
        const stepper = e.target.closest('.smart-stepper');
        if (!stepper) return;

        e.preventDefault();
        const entryIndex = parseInt(stepper.dataset.entryIndex);
        const key = stepper.dataset.key;
        const entry = tableData[entryIndex];

        dragState = {
          stepper,
          entry,
          key,
          startY: e.clientY,
          lastY: e.clientY,
          accumulatedDelta: 0,
        };

        stepper.classList.add('active');
      });

      document.addEventListener('mousemove', (e) => {
        if (!dragState) return;

        e.preventDefault();
        const deltaY = dragState.lastY - e.clientY; // ‰∏äÊãâÁÇ∫Ê≠£Ôºå‰∏ãÊãâÁÇ∫Ë≤†
        dragState.lastY = e.clientY;
        dragState.accumulatedDelta += deltaY;

        // ÊØèÁßªÂãï30pxËß∏Áôº‰∏ÄÊ¨°Ë™øÊï¥Ôºà0.5Â∞èÊôÇÔºâ
        const threshold = 30;
        if (Math.abs(dragState.accumulatedDelta) >= threshold) {
          const steps = Math.floor(Math.abs(dragState.accumulatedDelta) / threshold);
          const direction = dragState.accumulatedDelta > 0 ? 1 : -1;

          for (let i = 0; i < steps; i++) {
            adjustOTValue(dragState.entry, dragState.key, direction);
          }

          // Êõ¥Êñ∞Ë¶ñË¶∫
          if (dragState.key === 'vH' || dragState.key === 'vM') {
            const [h, m] = dragState.entry.endTime.split(':');
            dragState.stepper.textContent = (dragState.key === 'vH') ? h : m;
          } else {
            dragState.stepper.textContent = dragState.entry[dragState.key].toFixed(1);
          }
          dragState.stepper.classList.add('has-value');

          const card = dragState.stepper.closest('.data-card');
          if (card) {
            const entry = dragState.entry;
            const otTotal = entry.totalOtHoursNumeric || (Number(entry.v167 || 0) + Number(entry.v134 || 0) + Number(entry.v166 || 0) + Number(entry.v267 || 0));
            const val = otTotal.toFixed(1);
            const badge = card.querySelector('.scoreboard-badge');
            if (badge) {
              badge.textContent = val;
              badge.className = 'scoreboard-badge'; // reset
              const numericVal = parseFloat(val);
              if (numericVal >= 2 && numericVal < 3) badge.classList.add('green');
              else if (numericVal >= 3 && numericVal < 4) badge.classList.add('yellow');
              else if (numericVal >= 4 && numericVal < 5) badge.classList.add('orange');
              else if (numericVal >= 5 && numericVal < 6) badge.classList.add('red');
              else if (numericVal >= 6) badge.classList.add('purple');
            }

            // Êõ¥Êñ∞ Daily OT Chip
            const dailyChip = card.querySelector('.daily-total-chip span');
            if (dailyChip) dailyChip.textContent = `+${Math.round(entry.total)}`;
          }

          // Also Trigger Month Header Update from Stepper Drag? 
          // No, drag adjusts values directly for UI, but doesn't call updateAll until end?
          // Wait, current logic calls adjustOTValue -> updateAll(null, true).
          // So updateMonthStatsDOM() is already called in updateAll.

          dragState.accumulatedDelta = dragState.accumulatedDelta % threshold;
        }
      });


      // Mouse Up
      document.addEventListener('mouseup', () => {
        if (dragState) {
          dragState.stepper.classList.remove('active');
          dragState = null;
        }
      });

      // Touch Start
      container.addEventListener('touchstart', (e) => {
        const stepper = e.target.closest('.smart-stepper');
        if (!stepper) return;

        const touch = e.touches[0];
        const entryIndex = parseInt(stepper.dataset.entryIndex);
        const key = stepper.dataset.key;
        const entry = tableData[entryIndex];

        dragState = {
          stepper,
          entry,
          key,
          startY: touch.clientY,
          lastY: touch.clientY,
          accumulatedDelta: 0,
        };

        stepper.classList.add('active');
      });

      // Touch Move
      document.addEventListener('touchmove', (e) => {
        if (!dragState) return;

        // e.preventDefault(); // Passive false handled at attachment
        if (e.cancelable) e.preventDefault();

        const touch = e.touches[0];
        const deltaY = dragState.lastY - touch.clientY;
        dragState.lastY = touch.clientY;
        dragState.accumulatedDelta += deltaY;

        const threshold = 30;
        if (Math.abs(dragState.accumulatedDelta) >= threshold) {
          const steps = Math.floor(Math.abs(dragState.accumulatedDelta) / threshold);
          const direction = dragState.accumulatedDelta > 0 ? 1 : -1;

          for (let i = 0; i < steps; i++) {
            adjustOTValue(dragState.entry, dragState.key, direction);
          }

          dragState.stepper.textContent = dragState.entry[dragState.key].toFixed(1);
          if (dragState.entry[dragState.key] > 0) {
            dragState.stepper.classList.add('has-value');
          } else {
            dragState.stepper.classList.remove('has-value');
          }

          // Scoreboard (Touch)
          const card = dragState.stepper.closest('.data-card');
          if (card) {
            const entry = dragState.entry;
            const otTotal = entry.totalOtHoursNumeric || (Number(entry.v167 || 0) + Number(entry.v134 || 0) + Number(entry.v166 || 0) + Number(entry.v267 || 0));
            const val = otTotal.toFixed(1);
            const badge = card.querySelector('.scoreboard-badge');
            if (badge) {
              badge.textContent = val;
              badge.className = 'scoreboard-badge';
              const numericVal = parseFloat(val);
              if (numericVal >= 2 && numericVal < 3) badge.classList.add('green');
              else if (numericVal >= 3 && numericVal < 4) badge.classList.add('yellow');
              else if (numericVal >= 4 && numericVal < 5) badge.classList.add('orange');
              else if (numericVal >= 5 && numericVal < 6) badge.classList.add('red');
              else if (numericVal >= 6) badge.classList.add('purple');
            }
            const dailyChip = card.querySelector('.daily-total-chip span');
            if (dailyChip) dailyChip.textContent = `+${Math.round(entry.total || 0)}`;
          }

          dragState.accumulatedDelta = dragState.accumulatedDelta % threshold;
        }
      }, { passive: false });

      // Touch End
      document.addEventListener('touchend', () => {
        if (dragState) {
          dragState.stepper.classList.remove('active');
          dragState = null;
        }
      });
    }


    function initTabNavigation() {
      const tabBtns = document.querySelectorAll('.tab-navigation .tab-btn');
      if (tabBtns.length > 0) {
        tabBtns.forEach(btn => {
          // We only have one button now (Dashboard Toggle).
          // Logic handled separately.
        });
      }
    }

    // New Toggle Button Logic (Header)
    const toggleBtn = document.getElementById('viewToggleBtn');
    const logoCard = document.getElementById('logoCard');

    function switchToAnalytics() {
      document.getElementById('overview-tab').classList.remove('active');
      document.getElementById('analytics-tab').classList.add('active');
    }

    function toggleView() {
      const overview = document.getElementById('overview-tab');
      const analytics = document.getElementById('analytics-tab');

      if (overview.classList.contains('active')) {
        // Switch to Analytics
        overview.classList.remove('active');
        analytics.classList.add('active');
        // Update stats
        if (window.charts && window.charts.overtime) window.charts.overtime.resize();
        if (window.charts && window.charts.income) window.charts.income.resize();
        updateCharts();
        updateAnalyticsStats();
      } else {
        // Switch to Overview
        analytics.classList.remove('active');
        overview.classList.add('active');
      }
    }

    if (toggleBtn) {
      toggleBtn.addEventListener('click', toggleView);
    }

    if (logoCard) {
      logoCard.addEventListener('click', () => {
        // User requested: "Clicking homepage logo... analysis page...".
        // So force switch to analytics side.
        const overview = document.getElementById('overview-tab');
        const analytics = document.getElementById('analytics-tab');
        if (overview.classList.contains('active')) {
          toggleView();
        }
      });
    }

    // ========== DOM ËºâÂÖ•ÂæåÂàùÂßãÂåñ ==========
    document.addEventListener('DOMContentLoaded', () => {
      // Á∂ÅÂÆö„ÄåÂõûÂÇ≥Âà∞ Google Sheet„ÄçÊåâÈàï
      const saveBtn = document.getElementById('saveToSheetBtn');
      if (saveBtn) {
        saveBtn.addEventListener('click', async () => {
          try {
            saveBtn.disabled = true;
            await saveToSheet();
          } catch (err) {
            console.error('[OT] Save button error:', err);
            alert('‰∏äÂÇ≥ÁôºÁîüÈ†êÊúüÂ§ñÈåØË™§: ' + (err.message || err));
          } finally {
            saveBtn.disabled = false;
          }
        });
      }

      // Á∂ÅÂÆöË®∫Êñ∑ÊåâÈàï
      const diagBtn = document.getElementById('runDiagnosticsBtn');
      if (diagBtn) {
        diagBtn.addEventListener('click', runDiagnostics);
      }

      setTimeout(() => {
        initTheme();
        initTabNavigation();
        populateMonthFilter();
        try {
          initCharts();
          updateCharts();
          updateAnalyticsStats();
        } catch (e) {
          console.error('[OT] Error initializing charts/stats in DOMContentLoaded:', e);
        }
        initSmartStepperEvents(); // ÂàùÂßãÂåñÊãñÊõ≥‰∫ã‰ª∂
        initAddCardSteppers(); // ÂàùÂßãÂåñÊñ∞Â¢ûÂç°ÁâáÊãñÊõ≥
        console.log('[OT] ÂçáÁ¥öÂäüËÉΩÂ∑≤ËºâÂÖ• ‚úÖ');
      }, 500); // Reduced delay
    });
  })(typeof globalThis !== 'undefined' ? globalThis : this);
</script>